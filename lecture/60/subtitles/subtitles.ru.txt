Добрый день, уважаемые студенты! Я рад вас видеть на очередной лекции. Сегодня мы с вами поговорим про <span translate="no">Networking</span> и <span translate="no">Content Delivery</span>. Итак, давайте начнем.
Сегодняшняя наша лекция поделена на шесть частей. В первой части мы поговорим про основы сетей и рассмотрим базовые понятия, т.е. о <span translate="no">Networking basics</span>. Далее, в следующие три части, поговорим про сервис <span translate="no">Amazon Virtual Private Cloud</span> или чаще вы можете встретить как <span translate="no">Amazon VPC</span>. Затронем темы <span translate="no">VPC networking</span> и <span translate="no">VPC security</span>. Последние две темы это отдельные два сервиса, первый это – сервис <span translate="no">Amazon Route</span> 53, а второй это – сервис <span translate="no">Amazon CloudFront</span>.
Мы начинаем первую секцию, это основы сетей. Мы рассмотрим основы сетей для того, чтобы облегчить вам понимание следующих секций, а именно секции, когда мы говорим про сети в <span translate="no">AWS</span>, в частности сервис <span translate="no">Amazon VPC</span>. Что такое сеть? Сеть – это два или более клиентских машин, соединенных между собой для обмена информации. Сеть может быть поделена на так называемые логические части, которые называются <span translate="no">subnets</span>. Для того, чтобы соединить машины между собой, нам необходимо сетевое оборудование. Как сетевое оборудование может выступать <span translate="no">switch</span> или <span translate="no">router</span>. У каждой машины внутри сети есть уникальный <span translate="no">IP</span>-адрес, который идентифицирует это устройство внутри определенной сети.
<span translate="no">IP</span>-адрес – это некоторое числовое обозначение в десятичной системе счисления, которое состоит из четырех частей. Далее машина переводится в двоичную систему счисления, как вы видите, и таким образом программа на низшем уровне работает с этим <span translate="no">IP</span>-адресом. Мы же его видим в десятичной системе счисления, и как пример вы видите 192.0.2.0. Каждый отсек, раздел внутри <span translate="no">IP</span>-адреса это какое-то число, которое может принимать значения от нуля до 255, т.е. 256 уникальных значений. 256 это 2 в степени 8, что говорит о том, что в двоичной системе счисления для обозначения чисел от нуля до 255 нам нужно выделить 8 бит. Начиная от нулей 8 раз (00000000), заканчивая единичками 8 раз (11111111). Таким образом <span translate="no">IP</span>-адрес в бинарном формате представляет из себя 8 умноженное на 4 = 32 бита.
Мы с вами проговорили, что <span translate="no">IP</span>-адрес состоит из 32 битов. Такой адрес называется <span translate="no">IPv4</span>-адрес. У нас также есть другой вид <span translate="no">IP</span>-адреса, это <span translate="no">IPv6</span>, который состоит из 128 битов, и оно может сгенерировать еще большее количество уникальных <span translate="no">IP</span>-адресов для конкретной сети. Когда мы говорим про <span translate="no">IPv6</span>-адрес, то оно представлено в виде 8 групп. В каждой группе могут выступать буквы и цифры. Мы видим этот адрес в шестнадцатеричной системе счисления и каждая группа из себя представляет 16 битов, и может принимать значение от нуля до <span translate="no">FFFF</span>. Это опять же повторюсь в шестнадцатеричной системе счисления. В работе вы не так часто будете сталкиваться напрямую с <span translate="no">IPv6</span>-адресами. В основном будете работать с <span translate="no">IPv4</span>-адресами. Поэтому давайте рассмотрим ее по подробнее.
В локальной сети для того, чтобы определить список возможных значений <span translate="no">IPv4</span>-адресов, мы используем так называемый <span translate="no">CIDR</span> блок. <span translate="no">CIDR</span> расшифруется как <span translate="no">Classless Inter-Domain Routing</span>. Он записывается в следующем формате: это стартовый, т.е. самый первый <span translate="no">IP</span>-адрес в формате <span translate="no">IPv4</span>, далее слэш и какой-то номер, который может принимать значение от 0 до 32. И означает, какое количество битов у нас зафиксировано. Мы с вами помним, что <span translate="no">IPv4</span>-адрес состоит из 32 битов. Поэтому если мы видим, что в <span translate="no">CIDR</span> блоке написано 24, это говорит о том, что 24 бита из 32 зафиксировано и меняться не может. Таким образом, 8 битов могут меняться. Когда мы говорим 8 битов, то это 2 в 8 степени количества уникальных <span translate="no">IP</span>-адресов, 2 в степени 8 это 256. Таким образом, конкретно вот <span translate="no">CIDR</span> блок, указанный на нашем слайде, может принимать 256 уникальных <span translate="no">IP</span>-адресов. Самый первый <span translate="no">IP</span>-адрес, который относится к этой сети, это 192.0.2.0. Таким образом, дальше идет от 0 последняя часть, которая у нас может меняться, 0.1.2.3.4. И так до самого последнего, который будет иметь <span translate="no">IP</span>-адрес 192.0.2.255. Хорошо. Я надеюсь здесь понятно, а для того чтобы закрепить материал, мы с вами сделаем следующую активность.
Давайте представим, что у нас есть <span translate="no">CIDR</span> блок, у которого первая часть совпадает, то есть 192.0.2.0 слэш вместо 24 будет 16. Давайте остановим это видео и попробуем посчитать, какое количество уникальных адресов будет в этой сети с таким <span translate="no">CIDR</span> блоком. Хорошо, я думаю, все из вас справились. Правильный ответ это 65536. Как мы вышли на это число? Мы с вами говорили, что <span translate="no">CIDR</span> блок у нас 192.0.2.0/16. Это говорит о том, что из 32 битов <span translate="no">IP</span>-адреса 16 у нас зафиксированы. Значит, ровно 16 битов у нас <span translate="no">flexible</span>, то есть могут меняться. Когда мы говорим 16 битов, это значит 2 в степени 16 уникальных <span translate="no">IP</span>-адресов. Если мы посчитаем 2 в степени 16, это 65536. Хорошо, я думаю, здесь стало более понятнее.
Давайте разберем еще два граничных случая. Представим, что у нас <span translate="no">CIDR</span> блок следующего вида 192.0.2.0/32. Давайте сделаем еще одну активность и попробуйте посчитать, какое количество <span translate="no">IP</span>-адресов есть в этом <span translate="no">CIDR</span> блоке. Можете остановить видео. Хорошо, я очень надеюсь, что каждый из вас смог правильно посчитать и получить верный ответ. Правильный ответ – это 1. <span translate="no">CIDR</span> блок, где окончание /32 идентифицирует одну машину. Как это посчитать? Когда мы говорим /32, это говорит о том, что 32 бита у нас зафиксированы. А так как у нас всего в <span translate="no">IPv4</span> адресе 32 бита, то чтобы посчитать, какое количество уникальных адресов у нас есть, мы отнимаем от 32 количество зафиксированных битов, а они у нас тоже 32. 32-32 получается 0, а 2 в степени 0 у нас 1. Таким образом, вы запомните, что в <span translate="no">Amazon</span>, когда вы работаете в <span translate="no">AWS Management Console</span>, для того чтобы указать конкретный <span translate="no">IP</span>-адрес, вы знаете что <span translate="no">CIDR</span> блок – это /32, ну и указываете, соответственно, ваш <span translate="no">IP</span>-адрес.
И второй граничный случай, я не буду его задавать как активность, давайте сразу отвечу. Когда мы говорим, что у нас <span translate="no">CIDR</span> блок 0.0.0.0/0, в этом случае мы понимаем, что мы начинаем с самого первого <span translate="no">IP</span>-адреса, так как у нас 0 количество зафиксированных битов, то все биты могут меняться, т.е. <span translate="no">flexible</span>. Это говорит о том, что у нас количество уникальных адресов в этой сети 2 в степени 32, и это представляет из себя весь интернет. Также в <span translate="no">AWS Management Console</span>, когда вам нужно указать, что доступ открываете всему интернету, либо <span translate="no">route</span> путь прокладываете до интернета, либо запрещаете выход в интернет, то как <span translate="no">CIDR</span> блок вы всегда можете указывать все нули через точку слеш 0, это и будет интернетом.
Следующая модель, с которой нам нужно познакомиться, возможно вы ее уже прошли, это <span translate="no">OSI</span> модель, т.е. <span translate="no">Open Systems Interconnection Model</span>. Основная идея этой модели в том, что она концептуально описывает, как данные передаются по сети, т.е. у нас есть 7 уровней, начиная от <span translate="no">application</span>, заканчивая физическим уровнем, когда мы работаем на уровне последовательности единичек и нулей. А самый верхний уровень <span translate="no">application</span>, это когда мы работаем по протоколу <span translate="no">HTTP</span>, <span translate="no">HTTPS</span> и другие. Таким образом, когда мы делаем <span translate="no">HTTP request</span> на какой-то сайт, то наш запрос, он с верхнего уровня опускается до самого нижнего, и в итоге последовательность нулей и единичек от нас идет к нашему получателю. Как только наша последовательность единичек и нулей, то есть наши данные или наш запрос дойдет до получателя, он обратно расшифровывает вот эту последовательность и поднимается на верхний уровень <span translate="no">application</span> для того, чтобы прочитать, понять и возможно обратно ответить каким-то сообщением. Ответ также будет проходить, опускаться с верхнего уровня до нижней, и как только придет вам, вы для того, чтобы прочитать эту последовательность, будете от самого нижнего уровня подниматься до самого верхнего и получите тот ответ в исходном виде, который вам был отправлен. Этой информации вам достаточно для того, чтобы понимать, как функционирует сеть, как данные проходят по сети и в целом легче понять, как работает сервис <span translate="no">Amazon VPC</span>.
Мы с вами переходим ко второй части нашей лекции и подробнее познакомимся с сервисом <span translate="no">Amazon VPC</span>. <span translate="no">Amazon VPC</span> расшифровывается как <span translate="no">Amazon Virtual Private Cloud</span>. Это сервис, который позволяет вам настроить логически изолированную сеть в облаке. У вас есть полный контроль над этой сетью, и вы можете создавать ресурсы в этой вашей сети. Более того, вы можете применять любые кастомные настройки в этой сети, а также есть несколько уровней безопасности, это <span translate="no">Security Group</span> и <span translate="no">Network Access Control Lists</span>, либо чаще вы встречаете как <span translate="no">Network ACLs</span>.
Здесь вы можете видеть схему, которая объясняет, как <span translate="no">VPC</span> может быть расположена в облаке. Когда мы говорим <span translate="no">VPC</span>, она присутствует только в одном <span translate="no">AWS</span> аккаунте. Также <span translate="no">VPC</span> полностью должна находиться в одном регионе. Если вам нужно использовать несколько регионов, то значит у вас будет по одному <span translate="no">VPC</span> на каждом из регионов. Мы с вами помним, что в рамках региона у нас может быть несколько <span translate="no">availability zone</span>. Таким образом, одна <span translate="no">VPC</span> может находиться в нескольких <span translate="no">availability zone</span>-ах.
<span translate="no">VPC</span> идентифицируется <span translate="no">CIDR</span> блоком, который мы ранее поговорили. Также внутри <span translate="no">VPC</span> мы можем делать некоторые логические группы, которые называются <span translate="no">subnets</span>. <span translate="no">Subnets</span> тоже идентифицируются <span translate="no">CIDR</span> блоком меньшего размера. И <span translate="no">range</span>, т.е. возможные значения <span translate="no">IP</span>-адресов <span translate="no">subnet</span>, они должны входить в возможные значения <span translate="no">VPC</span>. Касательно <span translate="no">subnets</span>, они могут быть двух видов. Первый это <span translate="no">private</span>, второй это <span translate="no">public</span>. <span translate="no">Public</span> это те <span translate="no">subnets</span>, которые доступны из интернета. А <span translate="no">private</span> это те <span translate="no">subnets</span>, которые недоступны из интернета.
Пару слов хотелось бы сказать о том, в какой размерности могут быть <span translate="no">CIDR</span> блоки у <span translate="no">VPC</span>. Самый максимальный размер это 65536 уникальных <span translate="no">IP</span>-адресов, что равняется <span translate="no">CIDR</span> блоку /16. Самые маленькие это 16 <span translate="no">IP</span>-адресов. И в <span translate="no">CIDR</span> блоке она записывается как /28, т.е. 4 вида у нас могут быть <span translate="no">flexible</span>, т.е. меняться. Когда мы говорим про <span translate="no">CIDR</span> блок для <span translate="no">VPC</span>, очень нужно аккуратно и ответственно подойти к размеру этого <span translate="no">CIDR</span> блока, а также к начальному <span translate="no">IP</span>-адресу. Связано это с тем, что <span translate="no">CIDR</span> блок, который вы назначите для <span translate="no">VPC</span>, позже уже не может быть изменен. Таким образом, если вам нужно поменять <span translate="no">CIDR</span> блок, вам необходимо создать новый <span translate="no">VPC</span>. Если у вас в старом <span translate="no">VPC</span> есть какие-то ресурсы, которые работают, вам необходимо выделить время, силы, деньги, людей для того, чтобы все эти ресурсы перенести в новый <span translate="no">VPC</span> с новым <span translate="no">CIDR</span> блоком. Это может быть очень дорого и неприятно, поэтому правило такое, что вы с каким-то достаточным запасом выбираете размер <span translate="no">VPC</span>. Более того, всегда помните, что <span translate="no">VPC</span> между собой пересекаться не могут. Даже если у вас <span translate="no">VPC</span> находится в разных <span translate="no">AWS</span> аккаунтах, то такая рекомендация на будущее – создавать <span translate="no">CIDR</span> блоки не пересекающимися, так как есть разные сервисы в <span translate="no">AWS</span>, которые помогают <span translate="no">VPC</span> из разных аккаунтов соединять между собой. Если <span translate="no">CIDR</span> блоки этих <span translate="no">VPC</span> будут пересекаться, то вы их между собой не сможете соединить, поэтому учитывайте всегда этот момент.
Другой момент – это касательно <span translate="no">subnet</span>-ов. Как уже говорилось ранее, <span translate="no">CIDR</span> блок <span translate="no">subnet</span>-а должен входить в <span translate="no">CIDR</span> блок <span translate="no">VPC</span>. Размер <span translate="no">subnet</span>-а максимально может быть равен размеру самого <span translate="no">VPC</span>. Таким образом, в этом <span translate="no">VPC</span> будет только один <span translate="no">subnet</span>. Если же мы внутри <span translate="no">VPC</span> создаем несколько <span translate="no">subnet</span>-ов, нам надо убедиться в том, что <span translate="no">CIDR</span> блоки в рамках одного <span translate="no">VPC</span> также не пересекаются.
Когда мы создаем <span translate="no">CIDR</span> блок неважно большой или маленький, так же неважно для <span translate="no">VPC</span> либо для с<span translate="no">subnet</span>-а  в облаке <span translate="no">AWS</span>, <span translate="no">AWS</span> резервирует 5 <span translate="no">IP</span>-адресов для системного использования. Вы можете видеть, что самый первый <span translate="no">IP</span>-адрес в <span translate="no">range CIDR</span> блока зарезервирован под <span translate="no">network address</span>, второй – для <span translate="no">internal communication</span>, третий – для <span translate="no">DNS resolution</span>, четвертый – для будущего использования, и самый последний – он используется как <span translate="no">network broadcast address</span>. Таким образом, для <span translate="no">CIDR</span> блока, у которого размерность – /24, т.е. 256 уникальных адресов, фактически для вашего использования доступны минус 5, это значит 251 <span translate="no">IP</span>-адресов.
Давайте здесь делаем очередную активность. И вопрос следующий. Представьте у вас следующий <span translate="no">CIDR</span> блок: 10.0.0.0/28. Вопрос. Какое количество <span translate="no">IP</span>-адресов внутри этого <span translate="no">CIDR</span> блока доступно для вашего использования? Хорошо, я думаю, все вы справились. Давайте попробуем вместе посчитать. <span translate="no">CIDR</span> блок с размером /28 говорит о том, что 28 битов в 30-битном <span translate="no">IPv4 CIDR</span> блоке зафиксированы, значит, количество битов, которое может меняться, 32 минус 28 равно 4. Какое количество <span translate="no">IP</span>-адресов для 4 битов мы можем посчитать следующим образом. Для этого мы считаем 2 в степени, число которое вышло, в нашем случае 4, 2 в степени 4 равняется 16. Как только что мы сказали, 5 адресов <span translate="no">AWS</span> резервирует для системного использования. Таким образом, 16 минус 5 равняется 11. И ответ у нас для <span translate="no">CIDR</span> блока с размером /28 у нас не 16, а 11 уникальных <span translate="no">IP</span>-адресов, которые доступны для нашего пользования.
Когда мы говорим про публичные <span translate="no">IP</span>-адреса, выделяют два вида. Первый – это публичный <span translate="no">IPv4</span>-адрес и <span translate="no">ElasticIP</span>-адрес. Чем они отличаются? Когда мы создаем <span translate="no">VPC</span> внутри облака <span translate="no">AWS</span>, то все инстансы внутри этого <span translate="no">VPC</span> автоматически получают внутренний <span translate="no">IP</span>-адрес, который называется <span translate="no">private IP address</span>. Но параллельно с этим вы можете поставить галочку в пункте <span translate="no">Auto assign public IP address</span> во время создания <span translate="no">VPC</span>. Таким образом, помимо <span translate="no">private IP address</span>, все инстансы будут получать <span translate="no">public IPv4 address</span>, который является динамическим <span translate="no">public IP address</span>. Если же вам необходим статический публичный <span translate="no">IP</span>-адрес, в этом случае вы можете воспользоваться функционалом <span translate="no">Elastic IP address</span>, который эту возможность предоставляет. Вы этот <span translate="no">IP</span>-адрес можете привязать к ресурсу, а именно к инстан<span translate="no">c</span>у либо к интерфейсу внутри вашего <span translate="no">VPC</span>. Следует помнить, что услуга <span translate="no">Elastic IP address</span> также является платной. Таким образом, следует взять за правило все <span translate="no">Elastic IP address</span>, которые не привязаны к ресурсам, высвобождать для того, чтобы не платить впустую.
Пару слов хотелось бы сказать касательно <span translate="no">Elastic Network Interface</span>. Это отдельный ресурс, который вы можете привязать к инстан<span translate="no">c</span>у внутри вашего <span translate="no">VPC</span>, который может обслуживать некоторый <span translate="no">IPv4</span>-адрес. Помимо <span translate="no">Elastic Network Interface</span>, у каждого инстан<span translate="no">c</span>а внутри <span translate="no">VPC</span> есть так называемый <span translate="no">Default Network Interface</span>. К этому <span translate="no">Default Network Interface</span> привязывается <span translate="no">Private IPv4</span>-адрес, который выбирается из <span translate="no">CIDR</span> блока вашего <span translate="no">VPC</span>. К инстан<span translate="no">c</span>у вы можете привязывать определенное количество <span translate="no">Network Interface</span>-ов, и это количество зависит от типа инстан<span translate="no">c</span>а, чем она выше, тем она больше, тем большее количество <span translate="no">Network Interface</span> вы можете подключить к конкретному инстан<span translate="no">c</span>у.
Давайте подробнее поговорим, что такое <span translate="no">Route table</span>. <span translate="no">Route table</span> – это некая таблица, которая состоит из набора правил, <span translate="no">rule</span> или <span translate="no">routes</span>. Каждое правило идентифицируется местом отправки и местом назначения, или английскими терминами <span translate="no">destination and target</span>. Как <span translate="no">destination</span> у нас выступает некоторый <span translate="no">CIDR</span> блок, он может описывать наш <span translate="no">subnet</span>, а как <span translate="no">target</span> указывается уже некий ресурс. В любом <span translate="no">Route table</span> есть первый, самый основной <span translate="no">rule</span>. Это <span translate="no">rule</span>, который со всех наших <span translate="no">subnets</span> как <span translate="no">target</span> указывает <span translate="no">local</span>. Это нужно для того, чтобы все инстансы между нашими <span translate="no">subnet</span>-ами могли между собой взаимодействовать.
У <span translate="no">VPC</span> есть <span translate="no">Route table</span> по умолчанию, который называется <span translate="no">Main Route table</span>. Он автоматически создается и привязывается к нашему <span translate="no">VPC</span>. Важный момент – это то, что каждый <span translate="no">subnet</span> должен быть ассоциирован, т.е. привязан к одному из <span translate="no">Route table</span>. Но у каждого <span translate="no">Route Table</span> может быть несколько <span translate="no">subnet</span>-ов. Более того, у каждого <span translate="no">VPC</span> может быть не один, а несколько <span translate="no">Route table</span>. Таким образом вы гибко можете настроить все ваши <span translate="no">routes</span> между вашими <span translate="no">subnet</span>.
Мы завершаем вторую секцию. Давайте пройдемся по основным моментам, которые необходимо запомнить. <span translate="no">VPC</span> – это логически изолированная часть облака <span translate="no">AWS</span>, в которой мы можем создавать необходимые для нас ресурсы. <span translate="no">VPC</span> относится только к одному аккаунту и к одному определенному региону. Но <span translate="no">VPC</span> может находиться в нескольких <span translate="no">availability</span> зонах в рамках одного региона. <span translate="no">VPC</span> идентифицируется одним определенным <span translate="no">CIDR</span> блоком. Что такое <span translate="no">CIDR</span> блок мы проговорили в предыдущей секции. Каждый <span translate="no">VPC</span> может быть поделен на логические группы, которые называются <span translate="no">subnet</span>-ами. Каждый <span translate="no">subnet</span> также идентифицируется <span translate="no">CIDR</span> блоком, который должен входить в <span translate="no">CIDR</span> блок <span translate="no">VPC</span>. Также у нас есть такое понятие как <span translate="no">Route table</span>, это некий ресурс, который контролирует трафик между нашими <span translate="no">subnet</span>-ами внутри нашего <span translate="no">VPC</span>. У нас есть внутри каждого <span translate="no">Route table</span> встроенный путь <span translate="no">Local Route</span>, который нельзя удалить и который помогает нам предоставить возможность всем инстансам внутри разных <span translate="no">subnet</span>-ов общаться между собой в рамках одного <span translate="no">VPC</span>. Вы можете добавлять дополнительные <span translate="no">routes</span>, <span translate="no">rules</span>, или правила в ваши <span translate="no">Route table</span> для того, чтобы гибко настроить сетевые потоки внутри вашего <span translate="no">VPC</span>.
Мы с вами добрались до третьей секции. На третьей секции мы с вами поговорим про особенности настройки роутинга трафика внутри <span translate="no">VPC</span>. Одним из важных компонентов <span translate="no">VPC</span> является <span translate="no">Internet gateway</span>. <span translate="no">Internet gateway</span> используется для того, чтобы связать интернет с вашими инстансами внутри вашего <span translate="no">VPC</span>. Для того, чтобы ваш <span translate="no">public subnet</span> сделать публичным, то есть доступным из интернета, нам необходимо добавить <span translate="no">Internet gateway</span>, а также добавить один <span translate="no">route</span> в нашем <span translate="no">Route Table</span>, в котором как <span translate="no">destination</span> выступает интернет, то есть это 0.0.0.0/0, как <span translate="no">target</span> выступает наш <span translate="no">Internet gateway</span>.
Другой частый случай это когда для инстансов внутри <span translate="no">private subnet</span> необходимо выходить в интернет. При этом мы должны запретить доступ с интернета добираться до инстансов внутри <span translate="no">private subnet</span>. Для этих целей используется так называемый <span translate="no">Network Address Translation gateway</span>, чаще вы его будете встречать как <span translate="no">NAT gateway</span>. Для того, чтобы правильно настроить <span translate="no">gateway</span>, вам в первую очередь необходимо настроить <span translate="no">public subnet</span>. Как настроить <span translate="no">public subnet</span> мы с вами знаем. Повторюсь еще раз. Представим, у вас есть <span translate="no">route table</span> специально для вашего <span translate="no">public subnet</span>, и в нем как <span translate="no">destination</span> вы указываете весь интернет, как <span translate="no">target</span> указываете <span translate="no">Internet gateway</span>. Таким образом ваш <span translate="no">subnet</span> становится <span translate="no">public</span>. Далее внутри <span translate="no">public subnet</span> мы создаем <span translate="no">NAT gateway</span>. Теперь нам необходимо в <span translate="no">route table</span> для <span translate="no">private subnet</span> добавить <span translate="no">route</span> с интернета, то есть <span translate="no">destination</span> является интернет, а <span translate="no">target</span> является <span translate="no">NAT gateway</span>. После этого все инстансы внутри <span translate="no">private subnet</span> смогут выходить в интернет через <span translate="no">NAT gateway</span>. При этом <span translate="no">NAT gateway</span> обратно впускать уже запросы из интернета в <span translate="no">private subnet</span> давать не будет. Помимо <span translate="no">NAT gateway</span> есть еще вариант настроить <span translate="no">NAT instance</span>, то есть поднимается отдельный <span translate="no">EC2</span> инстанс и на нем настраивается <span translate="no">NAT gateway</span>. Отличие в том, что если инстанс сломается, с ним что-то произойдет, то интернет у вас пропадет, и его нужно будет заменить. В случае, когда мы говорим про <span translate="no">NAT gateway</span>, это <span translate="no">managed service</span> от <span translate="no">Amazon</span>, поэтому все возможные поломки, недоступность обеспечивается со стороны <span translate="no">Amazon</span> и в случае каких-то поломок прозрачно для вас заменяется на новый рабочий ресурс. Таким образом, есть рекомендация от <span translate="no">Amazon</span> как <span translate="no">best practice</span> использовать <span translate="no">NAT gateway</span> вместо <span translate="no">NAT instance</span>.
Одним интересным подходом, который вы можете реализовать внутри <span translate="no">AWS</span>, является <span translate="no">VPC sharing</span>. Идея ее в том, что вы можете свои <span translate="no">subnets</span> в рамках вашего <span translate="no">VPC</span> расшарить для <span translate="no">VPC</span> из другого аккаунта. Но этот аккаунт должен быть внутри общего <span translate="no">AWS Organizations</span>. Есть несколько нюансов. Это то, что вы можете видеть, а также изменять все те ресурсы внутри этого <span translate="no">shared subnet</span>, но при этом вы не видите и не можете изменять ресурсы других аккаунтов, которые находятся в этом <span translate="no">subnet</span>. То же самое касается всех участников, которые совместно работают внутри этого <span translate="no">shared subnet</span>. Этот подход очень удачно будет применен для тех <span translate="no">IT</span>-инфраструктур, у которых приложения внутри этой <span translate="no">IT</span>-инфраструктуры сильно взаимосвязаны. Таким образом, помимо того, что упрощается связь между приложениями, вы также можете сэкономить на некоторых общих ресурсах, таких как <span translate="no">NAT gateway</span>, <span translate="no">VPC Interface Endpoints</span> и так далее.
Еще одним интересным подходом, который вы можете воспользоваться внутри <span translate="no">AWS</span>, является <span translate="no">VPC peering</span>. Это та возможность, которая позволяет вам соединять между собой разные <span translate="no">VPC</span>. Эти <span translate="no">VPC</span> могут находиться как в одном аккаунте, так и в нескольких разных аккаунтах. Для того, чтобы произвести соединение, то есть <span translate="no">peering connection</span> между двумя <span translate="no">VPC</span>, нам необходимо, во-первых, создать <span translate="no">peering connection</span> ресурс, как вы видите по центру <span translate="no">pcx-id</span>, также внести для каждого <span translate="no">VPC route</span>-ы в соответствующих <span translate="no">route tables</span>.
Если говорить более подробно, то в <span translate="no">route table</span>-е <span translate="no">VPC A</span> нам необходимо добавить <span translate="no">route</span>, где <span translate="no">destination</span> является <span translate="no">CIDR</span> блок <span translate="no">VPC B</span>, а как <span translate="no">target</span> указать наш <span translate="no">peering connection</span> ресурс, то есть мы через него доходим до нашего <span translate="no">VPC B</span>. А в <span translate="no">route table</span>-е <span translate="no">VPC B</span> сделать обратную <span translate="no">route</span>, когда как <span translate="no">destination</span> указывается <span translate="no">CIDR</span> блок <span translate="no">VPC A</span>, а <span translate="no">target</span> является <span translate="no">peering connection</span> ресурс.
Когда мы говорим про <span translate="no">VPC peering</span>, у нас есть несколько ограничений. Самое первое и самое важное, это то, что <span translate="no">IP</span>-адреса, то есть <span translate="no">CIDR</span> блоки, они не могут пересекаться. Если они пересекаются, то вы не сможете настроить <span translate="no">peering connection</span>. Это как раз то, что я вам говорил на предыдущих слайдах, и вам всегда нужно иметь в виду, даже если <span translate="no">VPC</span> не планируется соединять между собой, то на всякий случай должен быть центральный список со всеми <span translate="no">CIDR</span> блоками, для того чтобы создавать их такими, чтобы не было пересечений. Другой момент, это то, что <span translate="no">VPC peering</span> нетранзитивный. Это говорит о том, что если мы настроим связь между <span translate="no">VPC A</span> и <span translate="no">VPC B</span>, далее между <span translate="no">VPC B</span> и <span translate="no">VPC C</span>, то связь между <span translate="no">VPC A</span> и <span translate="no">VPC C</span> не появится. Если вам нужно <span translate="no">VPC A</span> также соединить с <span translate="no">VPC C</span>, то необходимо настроить отдельный <span translate="no">peering connection</span>. И другим моментом, который также важно помнить, это то, что между двумя <span translate="no">VPC</span> вы можете настроить только один <span translate="no">peering connection</span>.
Все это время мы говорили с вами, как соединить сети внутри облака. Если же нам необходимо подключиться к облаку с нашего локального офиса, либо с локального дата-центра, такая возможность тоже есть. Для этого существует сервис <span translate="no">AWS Site-to-Site VPN</span>, который позволяет нам это все настроить. Давайте пройдемся по самым основным моментам, что необходимо сделать, чтобы предоставить доступ с локального офиса на ваш <span translate="no">VPC</span> в облаке. Самым первым нам необходимо создать так называемый <span translate="no">Virtual Private Network Gateway</span> или <span translate="no">Virtual Gateway</span>. Вы видите по центру экрана <span translate="no">Virtual Gateway ID</span>. Он привязывается к нашему <span translate="no">VPC</span>. Следующее, нам необходимо сконфигурировать так называемый <span translate="no">Customer Gateway</span>. <span translate="no">Customer Gateway</span> не является неким ресурсом, это является <span translate="no">AWS</span> ресурсом, который предоставляет информацию <span translate="no">AWS</span> о вашем <span translate="no">VPN</span>-девайсе, т.е. оборудование. Третье – нам необходимо настроить, например, для <span translate="no">Private Subnet</span>, <span translate="no">route table</span>, добавить <span translate="no">route</span>, где <span translate="no">destination</span> является наш локальный офис, то есть <span translate="no">CIDR</span> блок нашего локального офиса, а <span translate="no">target</span> является <span translate="no">vgw-id</span>, то есть это <span translate="no">Virtual Gateway ID</span>. После этого нам необходимо воспользоваться сервисом <span translate="no">AWS Site-to-Site VPN</span> для того, чтобы соединить между собой две системы. Это основные моменты, которые необходимо проделать для того, чтобы соединить локальную инфраструктуру с инфраструктурой в облаке <span translate="no">AWS</span>.
Следующий похожий сервис, который позволяет нам соединить нашу инфраструктуру в облаке с локальной инфраструктурой, является сервис <span translate="no">AWS Direct Connect</span>. Отличие ее в том, что в случае с предыдущим сервисом <span translate="no">AWS Site-to-Site VPN</span> мы настраиваем <span translate="no">VPN</span>-подключение через интернет. Таким образом, связь у нас есть, но скорость передачи данных и канал сети определяется размером канала вашего интернета, если у вас слабое интернет-подключение, это говорит о том, что у вас подключение к облаку через сервис <span translate="no">AWS Site-to-Site VPN</span> будет также небольшим. В случае, если вам необходимо передавать большой объем данных, либо передавать это все быстрее, то есть вариант в обход интернета подключиться к так называемым <span translate="no">DX-locations</span>, проще говоря, это глобальная инфраструктура <span translate="no">AWS</span>, и мы напрямую подключаемся к ней. В этом случае нет необходимости выходить в интернет, а напрямую подключать нашу локальную инфраструктуру с инфраструктурой в облаке.
Часто бывает такое, что вам необходимо вызвать некий <span translate="no">AWS</span> сервис из <span translate="no">VPC</span>, т.е. не все сервисы <span translate="no">AWS</span> могут работать внутри <span translate="no">VPC</span>, но тем не менее есть решение, которое позволяет нам, не покидая внутренней сети <span translate="no">AWS</span>, не выходя в интернет, добираться от <span translate="no">VPC</span> до необходимого нам сервиса <span translate="no">AWS</span>. Это так называемые <span translate="no">VPC endpoints</span>, выделя.т два вида, это <span translate="no">Interface VPC endpoint</span>, либо <span translate="no">Interface endpoint</span>, который поддерживает <span translate="no">AWS Private Link</span>. Другой вариант – это <span translate="no">Gateway endpoint</span>. В зависимости от того, какой сервис вам нужен, вы можете посмотреть в документации, какой из вариантов <span translate="no">endpoint</span>-а поддерживается и его соответственно использовать.
Давайте посмотрим на примере сервиса <span translate="no">Amazon S3</span>, что необходимо настроить для того, чтобы из <span translate="no">VPC</span> иметь возможность работать с сервисом <span translate="no">Amazon S3</span>. Для этого нам необходимо создать ресурс <span translate="no">VPC Endpoint</span>, а также в <span translate="no">route table</span> для нашего <span translate="no">subnet</span> прописать дополнительный <span translate="no">route</span>, где <span translate="no">destination</span> является <span translate="no">Amazon S3 ID</span>, а <span translate="no">target</span> является наш <span translate="no">VPC endpoint</span> ресурс.
Чуть ранее мы с вами поговорили про <span translate="no">VPC peering</span>, это когда нам необходимо два отдельных <span translate="no">VPC</span>, даже если они находятся в разных <span translate="no">AWS</span> аккаунтах, соединить между собой. Одним из ограничений этого подхода было то, что нет транзитивности, т.е. вы первый <span translate="no">VPC</span> соединяете со вторым, второй соединяете с третьим, и это не говорит о том, что появляется связь от первого до третьего. Если вам необходимо было первый <span translate="no">VPC</span> соединить с третьим, то необходимо настраивать отдельный <span translate="no">VPC peering connection</span> для того, чтобы связь появилась.
Теперь представьте такую ситуацию, что у вас слева на слайде несколько разных <span translate="no">VPC</span>, а также есть <span translate="no">VPN</span> соединения, и все они между собой взаимосвязаны. Для того, чтобы все <span translate="no">VPC</span> связать между собой, опять же это зависит от вашей бизнес потребности, то вам необходимо создать вот такое количество <span translate="no">VPC peering</span>. Поддерживать это может быть очень неудобно, и создается буквально большое количество <span translate="no">VPC peering</span> с каждым последующим разом. Для того, чтобы решить подобную проблему в существующих <span translate="no">IT</span>-инфраструктурах, предлагается использовать сервис <span translate="no">AWS Transit Gateway</span>. Идея ее в том, что она работает по принципу <span translate="no">Hub and Spoke Model</span>, то есть <span translate="no">AWS Transit Gateway</span> выступает как центральным хабом, и все <span translate="no">VPC</span>, которые соединяются к этому <span translate="no">Transit Gateway</span>, автоматически получают доступ ко всем <span translate="no">VPC</span>, которые уже подключены к <span translate="no">AWS Transit Gateway</span>. Таким образом, вы видите с правой стороны, как можно упростить вид вашей инфраструктуры, используя <span translate="no">AWS Transit Gateway</span>.
Мы с вами добрались до конца третьей секции. Давайте вкратце пройдемся о том, что мы прошли. Первый <span translate="no">VPC</span> компонент – это <span translate="no">Internet Gateway</span>, который помогает соединить интернет с нашими ресурсами в <span translate="no">public subnet</span>-е. Далее есть компонент <span translate="no">NAT Gateway</span> либо <span translate="no">NAT Instance</span>, который позволяет уже инстан<span translate="no">c</span>ам из <span translate="no">Private Subnet</span> добираться до интернета, при этом запрещать доступ из интернета, подключаться до инстан<span translate="no">c</span>ов внутри <span translate="no">private subnet</span>. Далее мы поговорили про <span translate="no">VPC Endpoint</span>. Идея в том, что не все сервисы бывают внутри <span translate="no">VPC</span>, и в зависимости от ваших бизнес требований, если вам нужно использовать этот сервис <span translate="no">AWS</span>, есть возможность, не выходя в интернет, а внутри сети <span translate="no">AWS</span>, локально, т.е. подключиться от этого сервиса к вашему <span translate="no">VPC</span>, для того чтобы это было безопасно, быстрее, и в целом вы получили доступ из <span translate="no">VPC</span> к необходимому вам сервису. Следующее – это <span translate="no">VPC peering</span>, это когда вам необходимо попарно соединить между собой ваши <span translate="no">VPC</span>, при этом <span translate="no">VPC</span> могут находиться в разных <span translate="no">AWS</span> аккаунтах. Следующее – это <span translate="no">VPC sharing</span>. Идея в том, что вы можете ваши <span translate="no">subnets</span> расшарить с другими <span translate="no">VPC</span>, с <span translate="no">VPC</span> с других <span translate="no">AWS</span> аккаунтов. Основной момент, который надо учитывать, это чтобы все аккаунты были в одном <span translate="no">AWS</span> О<span translate="no">rganizations</span>. Далее мы поговорили с вами про <span translate="no">AWS Site-to-Site VPN</span>. Идея в том, что вы можете вашу облачную инфраструктуру соединить с локальной инфраструктурой через интернет, прокинув специальное <span translate="no">VPN</span>-подключение. Есть и плюсы и минусы такого подхода. Другой вариант – это <span translate="no">AWS Direct Connect</span>. Идея в том, что вы не через интернет подключаетесь к облаку, а подключаетесь к глобальной инфраструктуре <span translate="no">AWS</span>. Таким образом выходить в интернет не нужно,и при этом вы получаете больше канал. И этот вариант лучше, если вам необходимо передавать большой объем информации с вашего локального офиса в облако либо обратно. И последнее то, что мы поговорили – это <span translate="no">AWS Transit Gateway</span>. Идея в том, что если ваши <span translate="no">VPC</span> должны быть тесно связаны между собой, и когда вы используете <span translate="no">VPC peering</span>, то создаете большое количество этих <span translate="no">VPC peering</span>-ов, то как решением может быть <span translate="no">AWS Transit Gateway</span>, когда у вас есть центральный ресурс <span translate="no">Transit Gateway</span>, к которому подключаются все ваши <span translate="no">VPC</span>. Таким образом все подключенные <span translate="no">VPC</span> получают доступ ко всем другим <span translate="no">VPC</span>, которые уже подключены к этому <span translate="no">Transit Gateway</span>.
Мы добрались до четвертой секции. И на этой секции мы поговорим про безопасность <span translate="no">VPC</span>. Давайте начнем. Начнем мы с <span translate="no">Security Groups</span>. <span translate="no">Security Groups</span> – это некий виртуальный <span translate="no">firewall</span> для ваших инстансов, который позволяет контролировать входящий и исходящий трафик. Важно запомнить, что <span translate="no">Security Groups</span> работают на уровне инстанса. Таким образом вы можете в рамках одного <span translate="no">subnet</span>-а для каждого инстанса внутри него настроить специальный набор <span translate="no">Security Groups</span>. Когда мы говорим про <span translate="no">Security Groups</span>, следует понимать это как набор правил, которые контролируют входящий и исходящий трафик. В только что созданной <span translate="no">Security Groups</span> у вас будет отсутствовать <span translate="no">Inbound Rules</span>, то есть входящий трафик. Таким образом сторонний хост не сможет обратиться и добраться до инстанса с новой созданной <span translate="no">Security Group</span>. Если мы говорим про <span translate="no">Outbound Rules</span>, то есть исходящий трафик, то по умолчанию он полностью разрешен и ничем не ограничен. Если вам необходимо ограничить исходящий трафик, то вы можете удалить <span translate="no">rule</span>, то есть правило, которое создается по умолчанию, и задать свои правила, которые в каком-то объеме ограничены.
Здесь также следует отметить, что <span translate="no">Security Groups</span> являются <span translate="no">stateful</span>, т.е. это означает, что когда вы с вашего инстанса делаете запрос к другому ресурсу, если у вас есть <span translate="no">Outbound traffic</span>, то запрос разрешается. Далее, когда вы получаете ответ на ваш запрос, вне зависимости от того, <span translate="no">Inbound Rule</span> разрешен или запрещен, вы его получаете, т.е. запоминается состояние. Обратное тоже верно, т.е. если разрешен <span translate="no">Inbound Rule</span> от внешнего ресурса, то запоминается состояние, что он пришел со стороны, так как он уже был разрешен. Мы запоминаем это состояние, и уже вне зависимости от того, разрешен ли исходящий трафик, он разрешается в любом случае и передает ответ обратно.
Давайте рассмотрим пример <span translate="no">Security Groups</span>. Вы здесь видите, есть настроенные <span translate="no">rules</span> для исходящего и входящего трафика. Если посмотреть на исходящие <span translate="no">rules</span>, то мы видим, что разрешены порты 80 и 443, т.е. <span translate="no">HTTP</span> и <span translate="no">HTTPS</span> доступ со всего интернета, т.е. любой <span translate="no">IPv4</span> адрес с интернета может подключаться к нашему инстансу. Другое, третье, это то, что как в <span translate="no">source</span> указан <span translate="no">CIDR</span> блок нашей сети, таким образом мы с локальной сети по порту 22, т.е. <span translate="no">SSH</span>, можем подключаться к инстансу, к которой привязана эта <span translate="no">Security Group</span>. Если мы говорим про исходящий трафик, то мы можем как <span translate="no">destination</span> указать <span translate="no">Security Group ID</span> наших баз данных и выдать разрешение на порт 1433, таким образом, инстанс этой <span translate="no">Security Group</span> может подключаться к базам данных по порту 1433. Это порт по умолчанию для <span translate="no">Microsoft SQL Server</span> баз данных.
Следующим компонентом, который позволяет обеспечить безопасность <span translate="no">VPC</span>, является <span translate="no">Network Access Control Lists</span>. Чаще вы ее будете встречать как <span translate="no">Network ACLs</span>. <span translate="no">Network ACLs</span> выступает как <span translate="no">firewall</span> и контролирует входящий и исходящий трафик на уровне <span translate="no">subnet</span>-ов. Оно является опциональным, поэтому использовать или нет это на ваше усмотрение. <span translate="no">Amazon</span> со своей стороны рекомендует ее использовать и продублировать входящие и исходящие <span translate="no">rules</span> для всех ваших <span translate="no">VPC</span>.
Когда мы говорим про <span translate="no">Network ACLs</span>, каждый <span translate="no">subnet</span> должен быть привязан к одному из <span translate="no">Network ACLs</span>. Если вы явно не указываете связь, то <span translate="no">subnet</span>-ы привязываются к дефолтовому <span translate="no">Network ACLs</span>. Здесь важный момент, это то, что каждый <span translate="no">subnet</span> может быть соединен только с одним <span translate="no">Network ACL</span>, тогда как несколько <span translate="no">subnet</span>-ов могут быть соединены с одним <span translate="no">Network ACL</span>. Когда вы один <span translate="no">subnet</span> перепривязываете к другому <span translate="no">Network ACL</span>, то предыдущая привязка удаляется.
<span translate="no">Network ACLs</span> выглядит следующим образом. Это пример <span translate="no">Network ACLs</span>, созданного по умолчанию. По умолчанию разрешается весь входящий и исходящий <span translate="no">IPv4 traffic</span>. Если это применимо, то <span translate="no">IPv6 traffic</span> также разрешается. Здесь следует отметить, что <span translate="no">Network ACLs</span> является <span translate="no">stateless</span>, т.е. не сохраняется состояние. Таким образом, когда вы делаете, представим, исходящий запрос на некий ресурс, если у вас разрешен <span translate="no">outbound traffic</span>, то запрос проходит. Далее, так как <span translate="no">Network ACLs</span> является <span translate="no">stateless</span>, то при возвращении ответа он также проверяет, если через <span translate="no">inbound traffic</span> он разрешен, тогда вы получаете ответ. Если же в <span translate="no">inbound traffic</span> прописано, что он не пропускает этот входящий трафик, то вы не получите ответа, даже если он дойдет до вашего получателя. Обратное тоже верно, т.е. для того, чтобы внешний ресурс получил от вас ответ, то должны быть разрешены и <span translate="no">outbound</span>, и <span translate="no">inbound traffic</span>. Иначе вы получите запрос от ресурса, но ответить этому ресурсу уже не сможете, так как не пропустит <span translate="no">Network ACLs</span> и нет соответствующего <span translate="no">rule</span> внутри <span translate="no">outbound traffic</span>.
Здесь вы можете видеть пример <span translate="no">Network ACLs</span>, уже заполненного. Когда мы создаем кастомный <span translate="no">Network ACLs</span>, то весь трафик входящий и исходящий, он запрещен. Поэтому по необходимости вам нужно добавить <span translate="no">rules</span>, т.е. правила, которые разрешают входящий либо исходящий трафик. Здесь вы можете видеть, что входящий трафик и исходящий трафик разрешен для <span translate="no">HTTPS</span> и <span translate="no">SSH</span> соединения. При этом по <span translate="no">HTTPS</span> могут подключаться любой <span translate="no">IPv4</span>-адрес, т.е. с интернета есть доступ, а с <span translate="no">SSH</span> могут подключаться только <span translate="no">IP</span>-адреса с <span translate="no">CIDR</span> блока 192.0.2.0/24, т.е. здесь вы можете указывать вашу локальную сеть.
Возможно, сейчас вам немного непонятно, чем же все-таки отличается <span translate="no">Security groups</span> от <span translate="no">Network ACLs</span>, поэтому давайте сравним в табличном виде, чем же они все-таки отличаются. Когда мы говорим про <span translate="no">Security groups</span>, то <span translate="no">Security groups</span> работают на уровне инстанса, тогда как <span translate="no">Network ACLs</span> работают на уровне <span translate="no">subnet</span>, т.е. привязывается к <span translate="no">subnet</span>. Когда мы говорим про правила, <span translate="no">Security groups</span> поддерживают только правила, которые что-то разрешают, т.е. разрешают трафик. Когда мы говорим про <span translate="no">Network ACLs</span>, там присутствуют не только правила, которые что-то разрешают, а также можно настроить правила, которые запрещают трафик. Когда мы говорим про <span translate="no">Security groups</span>, то оно является <span translate="no">stateful</span>, т.е. запоминает состояние. И это значит, что трафик, который смог войти, он обязательно выйдет, несмотря на <span translate="no">Outbound rules</span>. И обратное тоже верно. Если у вас есть <span translate="no">Outbound traffic</span>, который прошел, то вне зависимости от того, какие <span translate="no">Inbound rules</span> у вас прописаны, оно вернется обратно. Когда мы говорим про <span translate="no">Network ACLs</span>, она является <span translate="no">stateless</span>, т.е. она не запоминает состояние, и для того, чтобы запрос прошел успешно через <span translate="no">Network ACLs</span>, оно должно быть разрешено как в <span translate="no">Inbound rules</span>, так и в <span translate="no">Outbound rules</span>, иначе в какой-то момент она не пройдет. Четвертый момент, который отличается, это то, что <span translate="no">Security groups</span> для того, чтобы принять решение, разрешать трафик или нет, просматривает все имеющиеся <span translate="no">rules</span>, после чего принимает решение. А когда мы говорим про <span translate="no">Network ACLs</span>, он по приоритету сверху вниз просматривает все <span translate="no">rules</span>. В тот момент, когда мы находим правила, которые разрешают трафик, все оставшиеся правила не рассматриваются, и трафик разрешается. Мы заканчиваем четвертую секцию. Здесь мы с вами рассмотрели более подробно, что же такое <span translate="no">Security groups</span> и что такое <span translate="no">Network ACLs</span>. Оба эти компонента помогают нам защитить наши <span translate="no">VPC</span>.
Мы с вами добрались до пятой секции. И здесь мы поговорим про сервис <span translate="no">Amazon Route</span> 53. Это сервис, который предоставляет нам <span translate="no">DNS</span> сервис. Самыми простыми словами это значит то, что в тот момент, когда пользователи открывают сайт <span translate="no">www</span>.<span translate="no">example</span>.<span translate="no">com</span>, то этот сервис перенаправляет трафик на соответствующие <span translate="no">IP</span>-адреса, а именно <span translate="no">IP</span>-адреса нашей инфраструктуры, на наши инстансы. <span translate="no">Amazon Route</span> 53 поддерживает большой выбор сервисов <span translate="no">AWS</span>. Это может быть не только <span translate="no">Amazon EC2</span> инстан<span translate="no">c</span>ы, также это может быть <span translate="no">Amazon S3 buckets</span>, <span translate="no">Elastic Load Balancing</span> и другие сервисы. Внутри <span translate="no">Amazon Route</span> 53 можно гибко настроить трафик для того, чтобы реагировать на состояние таргет <span translate="no">IP</span>-адресов, т.е. <span translate="no">IP</span>-адресов, куда перенаправляет этот сервис и соответственно действовать, т.е. таким образом можно настроить перенаправление трафика в случае возникновения проблем у принимающей стороны. Также следует отметить, что черезт<span translate="no">Amazon Route</span> 53 мы можем покупать домены. Какие домены верхнего уровня доступны, вы можете посмотреть и ознакомиться на странице сервиса <span translate="no">Amazon Route</span> 53.
На этом слайде вы можете видеть, как обрабатывается запрос пользователя, когда он открывает определенный сайт. Когда пользователь вводит, например, <span translate="no">www</span>.<span translate="no">example</span>.<span translate="no">com</span>, название сайта, то этот запрос уходит на <span translate="no">DNS resolver</span>. Это такие сервера, которые сохраняют связки доменное имя и какой <span translate="no">IP</span>-адрес его обслуживает, либо информации о том, где, на каком источнике можно получить этот <span translate="no">IP</span>-адрес. В случае, если у <span translate="no">DNS resolver</span> этой информации нет, но он знает, куда пойти, он идет в сервис <span translate="no">Amazon Route</span> 53, который смотрит в своих настройках и соответственно возвращает <span translate="no">IP</span>-адрес этому <span translate="no">DNS resolver</span>. <span translate="no">DNS resolver</span> дальше возвращает этот <span translate="no">IP</span>-адрес пользователю, и это происходит прозрачно для пользователя. Когда он вводит в строке браузера, он видит уже открытый сайт. Но здесь есть два шага. Первый шаг мы с вами увидели. И второй шаг, как только браузер получает <span translate="no">IP</span>-адрес, он делает уже этот запрос на соответствующий <span translate="no">IP</span>-адрес и получает оттуда ответ, отображает пользователю. В строке ввода, в строке поиска у пользователя все так же останется то доменное имя, которое он ввел вначале.
<span translate="no">Amazon Route</span> 53 поддерживает несколько различных <span translate="no">policy</span>, которые помогают нам направлять и гибко настраивать наш трафик. Самый первый это <span translate="no">Simple routing</span>. Идея ее в том, что вы в настройках <span translate="no">Amazon Route</span> 53 указываете один или несколько <span translate="no">IP</span>-адресов, которые обслуживают ваше доменное имя. В тот момент, когда приходит запрос, то этот сервис в рандомном порядке, в случайном порядке отдаёт один из <span translate="no">IP</span>-адресов, и уже браузер на стороне пользователя переходит на этот <span translate="no">IP</span>-адрес, чтобы получить ответ на запрос пользователя.
Следующий более продвинутый <span translate="no">policy</span> – это <span translate="no">Weighted round robin routing</span>. Идея ее в том, что вы можете для списка ваших <span translate="no">IP</span>-адресов, серверов, которые обслуживают трафик, задать некоторые веса. И представим, у вас есть два сервера, один мощный, другой менее мощный. В этом случае вы можете, например, 75% трафика направить на большой сервер, а оставшиеся 25% на маленький.
Третий вариант – это <span translate="no">Latency routing</span>. Она более сложная по сравнению с предыдущими двумя. Идея ее в том, что она измеряет скорость ответа от определенных <span translate="no">IP</span>-адресов и выбирает тот, который быстрее всего отвечает. Давайте я приведу пример. Представим, наша инфраструктура развернута в двух <span translate="no">AWS</span> регионах. И по происшествию некоторого времени и сбора необходимой информации, <span translate="no">Amazon Route</span> 53 будет выдавать для пользователей тот регион, который для этого пользователя будет работать быстрее.
Следующее – это <span translate="no">Geolocation routing</span>. Идея в том, что мы можем для пользователей с определенного региона направлять на указанные нами сервера либо <span translate="no">IP</span>-адреса, которые обслуживают этот трафик. Это используется обычно для того, чтобы направлять трафик на соответствующий сайт с нужным языком. Представим, что мы как пользователь подключаемся из страны Центральной Азии, мы знаем русский язык, и в этом случае вы можете настроить сайт таким образом, что он направляет на версию сайта на русском языке. В случае, если подключается пользователь с англоязычной страны, в этом случае, соответственно, пользователя направят на те сервера, которые обслуживают англоязычный трафик.
Следующая <span translate="no">policy</span> – это <span translate="no">Geoproximity routing</span>. Идея в том, что в отличие от <span translate="no">Geolocation routing</span>, когда мы смотрим на локацию пользователей, в <span translate="no">Geoproximity routing</span> мы смотрим на расположение нашей инфраструктуры. И, соответственно, выдаем ответ.
Следующий – это <span translate="no">Failover routing</span>. Идея в том, что мы передаем <span translate="no">IP</span>-адреса <span translate="no">active</span> и <span translate="no">passive</span>. И в момент, когда с <span translate="no">active IP</span>-адресом или ресурсом, который обрабатывает трафик, все хорошо, весь трафик направляется туда. В случае возникновения некоторых проблем, то трафик автоматически перенаправляется на резервный <span translate="no">IP</span>-адрес для того, чтобы обработать и не пропустить каждый вопрос. В тот момент, когда <span translate="no">active</span> становится снова доступным, то срабатывает переключатель и весь трафик, основной трафик будет перенаправляться обратно на <span translate="no">active IP</span>-адреса.
Самый последний – это <span translate="no">Multivalue answer routing</span>. Идея ее в том, что во всех предыдущих случаях мы возвращали один конкретный <span translate="no">IP</span>-адрес пользователю. В случае с <span translate="no">Multivalue answer routing</span> мы передаем несколько <span translate="no">IP</span>-адресов, а далее уже браузер в зависимости от настроек либо алгоритма работы определяет, на какой <span translate="no">IP</span>-адрес нужно идти.
Здесь вы можете видеть пример использования сервиса <span translate="no">Amazon Route</span> 53 и какие выгоды она дает. Например, наша инфраструктура развернута в нескольких регионах. И в случае подключения пользователя с некоторого региона, который ближе к первому региону, а на стороне <span translate="no">Amazon Route</span> 53 у нас настроен <span translate="no">Latency-based routing</span>, в этом случае пользователь будет направлен на тот регион, который ему ближе. И в целом получит ответ намного быстрее, чем если бы запрос ушел на регион, находящийся немного дальше.
На этом слайде вы видите пример страницы <span translate="no">AWS</span>, где происходит настройка <span translate="no">Failover routing policy</span>. И пример этот дан для того, чтобы показать, что есть возможности гибко настроить правила направления нашего трафика. Если мы говорим про конкретный пример, то мы видим, что есть у нас <span translate="no">Failure threshold</span> 3, то есть если последовательно 3 запроса были неудачными, то у нас происходит переключение и весь трафик уходит на наш резервный <span translate="no">IP</span>-адрес, который обслуживает этот трафик. И дальше каждый либо 30 секунд, либо 10 секунд, <span translate="no">Request interval</span>, мы проверяем, можем ли мы обратно вернуться на наш <span translate="no">active IP</span>-адрес, который является основным.
На этом слайде приведен еще один пример настройки <span translate="no">Failover routing policy</span>. Представим, у нас есть инфраструктура, которая обслуживает основной трафик и в <span translate="no">Amazon Route</span> 53 эта инфраструктура является основным, то есть <span translate="no">Active Route</span>. И соответственно запрос доходит до наших <span translate="no">Amazon EC2</span> инстансов, которые обращаются к базе данных для того, чтобы вернуть какой-то динамический ответ. А на стороне <span translate="no">Amazon Route</span> 53 настроена <span translate="no">Failover</span>, в случае, если инстансы становятся недоступными, то у нас срабатывает <span translate="no">Failover policy</span>, и мы переключаемся на <span translate="no">Secondary</span>, то есть <span translate="no">Passive IP</span>-адреса. В этом случае мы можем направить трафик на наш статический веб-сайт, который хостится на сервисе <span translate="no">Amazon S3</span>. Таким образом мы не сможем обработать всех пользователей как положено, но по крайней мере можем направить на соответствующий веб-сайт, в котором они могут получить более-менее понятный ответ, и вы не потеряете ваших клиентов. В тот момент, когда <span translate="no">Amazon Route</span> 53 получит ответ, периодически проверяя, что наши <span translate="no">Amazon EC2</span> инстансы успешно могут принимать запросы, то происходит обратное переключение, и весь трафик уже идет на наши <span translate="no">Amazon EC2</span>инстансы.
Мы завершаем пятую секцию. Давайте вкратце остановимся на том, что мы прошли. Первое, это то, что <span translate="no">Amazon Route</span> 53 – это высокодоступный и масштабируемый сервис, который предоставляет нам <span translate="no">DNS</span>. Простыми словами, это тот сервис, который направляет наш трафик от нашего доменного имени к нашим инстансам, которые обрабатывают этот запрос. Через сервис <span translate="no">Amazon Route</span> 53 мы также можем покупать доменные имена. Какие верхнеуровневые домены доступны для нас, мы можем посмотреть на официальной странице этого сервиса. Далее, что важно отметить и что может прийти, и скорее всего придет на реальном экзамене <span translate="no">AWS</span>, это какие <span translate="no">Routing policy</span> существуют в <span translate="no">Amazon Route</span> 53. На самом деле, эти вопросы являются одними из самых простых. Вам достаточно понять, чем является каждая <span translate="no">Routing policy</span>, и этого будет достаточно, чтобы правильно ответить на вопрос. С подобными вопросами вы встретитесь на наших <span translate="no">Practice test</span>-ах и сможете на них попрактиковаться. После этого мы посмотрели несколько примеров использования сервиса <span translate="no">Amazon Route</span> 53 с инфраструктурой в <span translate="no">AWS</span>.
Мы добрались до самой последней секции в рамках нашей лекции и поговорим про сервис <span translate="no">Amazon CloudFront</span>. Это один из базовых сервисов, который используется практически во всех <span translate="no">IT</span>-инфраструктурах, которые так или иначе обрабатывают интернет-трафик. Этот сервис является <span translate="no">Content Delivery Network</span>, то есть <span translate="no">CDN</span>. Простыми словами, это тот сервис, который переносит все ваши медиафайлы ближе к вашим пользователям, так чтобы это работало быстрее, это было дешевле и в целом безопаснее для вас.
Давайте посмотрим на примере, почему важно и чем помогает нам <span translate="no">CDN</span> для улучшения пользовательского опыта. Когда пользователь делает запрос, он может проходить через несколько узлов для того, чтобы добраться до оригинального сервера и запросить ваши некоторые данные, медиаданные с вашего сервера. То расстояние от пользователя до наших серверов может быть достаточно большим и оно отражается на скорости работы вашего приложения. Это ухудшает пользовательский опыт. Поэтому есть такой подход как <span translate="no">CDN</span>, <span translate="no">Content Delivery Network</span>. Идея в том, что в некоторых узлах ваши медиаданные либо любые другие данные кэшируются. Таким образом пользователь не доходя до оригинальных, изначальных источников серверов может раньше получить необходимый контент и это все ускорит время обработки каждого запроса каждого пользователя. Таким образом, <span translate="no">Content Delivery Network</span>, то есть <span translate="no">CDN</span> является для нас решением. <span translate="no">Content Delivery Network</span> это понятие в области <span translate="no">IT</span>, не привязанное к <span translate="no">Amazon</span>. Поэтому это довольно таки давно существующая технология, подход. Идея в том, что это сеть связанных между собой серверов, которые кэшируют некоторый контент. Как контент может выступать <span translate="no">HTML</span> страницы, <span translate="no">CSS</span> страницы, <span translate="no">JavaScript</span> файлы, картинки, видео, аудиодорожки и т.д., т.е. любые медиафайлы. Более того, продвинутые <span translate="no">SDN</span> могут обрабатывать и кэшировать динамический контент. Таким образом, нет необходимости пользователям ждать, когда запрос от него дойдет до оригинального сервиса. Фактически где-то посередине в кэше сохранен или есть готовый ответ для этого пользователя, который он получает. И таким образом улучшается пользовательский опыт. Если мы говорим про <span translate="no">AWS</span>, тогда есть специальный сервис, который является <span translate="no">CDN</span>, т.е. <span translate="no">Content Delivery Network</span> называется <span translate="no">Amazon CloudFront</span>.
Мы с вами проговорили ранее, что такое глобальная инфраструктура <span translate="no">AWS</span>. Это когда у нас есть <span translate="no">AWS</span> регионы, в каждом регионе есть <span translate="no">availability zone</span>, в каждой <span translate="no">availability zone</span> есть дата-центры, и проговорили, что такое дата-центры. Также есть параллельная инфраструктура <span translate="no">AWS</span>, которая относится к <span translate="no">CloudFront</span> называется <span translate="no">Amazon CloudFront Infrastructure</span>. Состоит она из двух компонентов. Это <span translate="no">Edge locations</span>, а также <span translate="no">Regional edge caches</span>. Чем отличается? <span translate="no">Edge locations</span> – это те сервера, которые находятся наиболее близко к конечным пользователям. Таким образом, в нем сохраняется контент, который самый популярный, самый необходимый, который запрашивается чаще всего. Чуть дальше находится <span translate="no">Regional edge cache</span>, в котором сохраняется информация уже чуть большего региона. И в нем есть данные, которые также популярные, но менее популярные, чем те данные, которые находятся на <span translate="no">Edge locations</span>. Также это могут быть данные, которые по тем или иным причинам не поместились в <span translate="no">Edge locations</span>. Они передаются и сохраняются в кэше <span translate="no">Regional Edge cache</span>. После <span translate="no">Regional Edge cache</span> у нас уже самое дальнее расстояние – это напрямую обратиться к оригинальным источникам. Таким образом, повторюсь, у нас есть три шага, три узла. Самый дальний – это напрямую обращаться к оригинальным серверам. Чуть быстрее, если мы получаем контент из <span translate="no">Regional Edge cache</span>. И самый быстрый контент мы получаем из <span translate="no">Edge locations</span>.
Давайте пройдемся по основным преимуществам использования сервиса <span translate="no">Amazon CloudFront</span>. Первое – это то, что этот сервис быстрый, глобальный. Далее – это то, что мы можем настроить безопасность на наших конечных кэшируемых серверах. Мы можем дополнительно программировать поведение сервиса <span translate="no">Amazon CloudFront</span>, используя <span translate="no">AWS Lambda Edge</span>. Этот сервис является <span translate="no">CDN</span>, который максимально интегрирован с сервисами <span translate="no">AWS</span>. А также это решение, которое намного выгоднее и быстрее, чем если бы мы обслуживали наших интернет-пользователей напрямую с наших серверов.
<span translate="no">Amazon CloudFront</span> является платным ресурсом, но также, как и любой другой сервис <span translate="no">AWS</span>, мы оплачиваем только за то, что мы использовали. В рамках сервиса <span translate="no">Amazon CloudFront</span> мы оплачиваем за объем данных, которые мы передали в кэш-сервера. Также мы оплачиваем за количество запросов <span translate="no">HTTP</span> и <span translate="no">HTTPS</span>-запросов на эти кэш-сервера. Дополнительно оплачиваются <span translate="no">Invalidation requests</span>. Это когда нам необходимо по запросу очистить все кэш-сервера от наших данных. Обычно это требуется, когда мы находим какую-то ошибку и быстро ее исправляем. И хотим, чтобы пользователи получали обновленную версию приложения либо данных. В этом случае мы делаем <span translate="no">Invalidation Requests</span>. Другой вариант – это когда у нас большое обновление, и мы хотим, чтобы вот это большое обновление быстрее дошло до наших пользователей. В этом случае нам необходимо очистить кэш, и все пользователи, которые начинают запрашивать, первый пользователь сделает запрос через <span translate="no">CloudFront</span>, далее <span translate="no">CloudFront</span>, так как этих данных нет, сделает запрос на оригинальные сервера и получит эти данные, после чего закэширует. А все последующие пользователи, которые будут запрашивать эти же данные, уже будут получать не с оригинальных серверов, а быстрее уже с наших <span translate="no">Edge</span> серверов.
И еще один момент – это то, что есть возможность настроить так называемый <span translate="no">Dedicated IP custom SSL</span>. Это та опция, которая не часто используется пользователями <span translate="no">AWS</span>, но вам достаточно запомнить, что такая опция есть. Более подробно вы можете посмотреть на официальной документации сервиса <span translate="no">Amazon CloudFront</span>.
Мы закончили шестую последнюю секцию в рамках нашей лекции. Мы познакомились подробно с сервисом <span translate="no">Amazon CloudFront</span>, а также узнали, что же такое <span translate="no">CDN</span>, для чего оно используется, и также узнали, что есть на стороне <span translate="no">AWS</span> сервис, который предоставляет нам <span translate="no">CDN</span>. Из преимуществ использования <span translate="no">CloudFront</span> – это то, что это сервис глобальный, можно гибко настроить его, программировать его поведение, также есть возможность сделать необходимые настройки с точки зрения безопасности. Это тот сервис, который является сервисом <span translate="no">AWS</span>, соответственно, достаточно хорошо проинтегрирован с другими сервисами и является достаточно экономичным решением в случае, когда вы передаете большой объем информации до ваших пользователей ваших приложений.
На этом мы завершаем наше лекционное занятие. Давайте пройдемся по самым основным моментам, которые мы сегодня прошли. Это то, что мы рассмотрели основы сетей, не привязанные к <span translate="no">AWS</span>, но это та информация, которая поможет легче понять сервисы, связанные с <span translate="no">Networking</span> внутри <span translate="no">AWS</span>. Далее мы познакомились с сервисом <span translate="no">Amazon VPC</span>, рассмотрели ее дополнительные компоненты, в том числе компоненты, которые помогают обеспечить безопасность, это <span translate="no">Security groups</span> и <span translate="no">NetworkACLs</span>. После чего мы познакомились с сервисами <span translate="no">Amazon CloudFront</span> и <span translate="no">Amazon Route</span> 53, рассмотрели примеры использования этих сервисов и как эти сервисы помогают нам лучше построить нашу инфраструктуру в облаке.
Здесь вы можете видеть ссылки, которые могут вам понадобиться, если вы хотите дополнительно ознакомиться со всем тем, что мы прошли сегодня.
На этом мы завершаем наше лекционное занятие. Я надеюсь, вы узнали что-то новое сегодня для себя. И увидимся с вами на следующих наших активностях.

