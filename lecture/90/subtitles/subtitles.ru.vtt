WEBVTT

00:00:00.000 --> 00:00:05.640
Добрый день, уважаемые студенты!
Я рад вас видеть на очередной лекции.

00:00:05.640 --> 00:00:10.680
Мы продолжаем предыдущую тему, а именно
тему Compute. Сегодня у нас вторая часть.

00:00:10.680 --> 00:00:18.880
Итак, давайте начнем. В четвертой секции мы
поговорим про сервисы, связанные с контейнерами.

00:00:18.880 --> 00:00:24.080
Далее, в пятой секции, мы
поговорим про сервис AWS Lambda.

00:00:24.080 --> 00:00:29.000
И самая последняя, шестая секция,
про сервис AWS Elastic Beanstalk.

00:00:29.000 --> 00:00:36.920
Секция четвертая – Сервисы,
связанные с контейнерами.

00:00:36.920 --> 00:00:47.360
Перед тем как мы доберемся до контейнеров,
давайте вспомним. У нас есть физический сервер.

00:00:47.360 --> 00:00:53.920
Внутри дата-центров AWS физически
на определенном участке

00:00:53.920 --> 00:00:58.560
расположены максимально
мощные физические сервера.

00:00:58.560 --> 00:01:05.320
Далее, благодаря виртуализации,
этот физический виртуальный сервер

00:01:05.320 --> 00:01:11.800
подразделяется на независимые друг от
друга виртуальные инстансы Amazon EC2.

00:01:11.800 --> 00:01:16.320
Таким образом, в рамках сервиса
Amazon EC2 мы можем запрашивать

00:01:16.320 --> 00:01:21.040
более 50 различных типов,
отличающихся количеством

00:01:21.040 --> 00:01:28.700
ядер процессора, а также
количеством оперативной памяти.

00:01:28.700 --> 00:01:36.040
Теперь, двигаясь еще дальше, есть
еще один вариант виртуализации

00:01:36.040 --> 00:01:40.280
на уровне операционной системы,
когда мы устанавливаем

00:01:40.280 --> 00:01:46.600
операционную систему и поверх операционной
системы запускаем изолированный контейнер,

00:01:46.600 --> 00:01:51.480
т.е. если говорим про инстансы
Amazon EC2, там вы указываете

00:01:51.480 --> 00:01:54.520
во время создания определенную
операционную систему.

00:01:54.520 --> 00:01:58.200
Когда мы говорим про контейнер,
контейнер привязан к определенной

00:01:58.200 --> 00:02:02.280
операционной системе и запускается в
рамках этой операционной системы.

00:02:02.280 --> 00:02:08.120
Но все остальное, а именно библиотеки,
все конфигурации, код, run time,

00:02:08.120 --> 00:02:14.880
среда запуска вашей программы,
она вся изолирована и самодостаточная.

00:02:14.880 --> 00:02:24.400
Таким образом, мы говорим, что контейнер -
repeatable, т.е. оно легко переносимое,

00:02:24.400 --> 00:02:31.640
т.е. вы берете готовый контейнер и копируете ее,
запускаете в другом месте, в другом environment-е,

00:02:31.640 --> 00:02:39.280
и будет запускаться точно так же, т.к. содержит
все необходимое для своего функционирования.

00:02:39.280 --> 00:02:44.840
Еще другой важный момент, это то, что
виртуальные машины запускаются намного

00:02:44.840 --> 00:02:51.120
медленнее по сравнению с контейнерами.
Теперь двигаемся дальше.

00:02:51.120 --> 00:02:56.320
Для того чтобы создавать контейнеры, работать
с ними, нам нужна определенная программа.

00:02:56.320 --> 00:03:02.640
Самая популярная программа, которая позволяет
нам создавать контейнеры, это Docker-контейнер.

00:03:02.640 --> 00:03:10.760
Docker-контейнер, это такая сущность, которая
содержит в себе все необходимое для запуска и

00:03:10.760 --> 00:03:15.520
корректного функционирования вашего
приложения, а именно библиотеки,

00:03:15.520 --> 00:03:22.760
системные инструменты, код и
среда запуска вашей программы.

00:03:22.760 --> 00:03:27.880
Мы проговорили, что такое контейнер
самыми простыми словами.

00:03:27.880 --> 00:03:36.000
Теперь давайте копнем немножко глубже. Когда мы
говорим про виртуальные машины, с правой стороны

00:03:36.000 --> 00:03:43.400
пример deployment-a трех различных приложений,
которые работают с различными библиотеками.

00:03:43.400 --> 00:03:48.800
Они специально выделены различным цветом, т.е.
Application 1, Application 2, Application 3.

00:03:48.800 --> 00:03:56.200
Каждая из них запущена на инстансе Amazon EC2.
При этом вы видите, что операционная система

00:03:56.200 --> 00:04:01.760
изолирована друг от друга, т.е. VM1,
Virtual Machine 1, у нее своя операционная

00:04:01.760 --> 00:04:07.320
система, она может совпадать с другими, а
может и нет. Это зависит от самого приложения,

00:04:07.320 --> 00:04:16.680
т.е. виртуальная машина работает поверх
hypervisor-а. Следующий уровень виртуализации

00:04:16.680 --> 00:04:28.720
это контейнеры, т.е. выше hypervisor-а уровень
операционной системы нашего инстанса Amazon EC2.

00:04:28.720 --> 00:04:33.840
Так вот в рамках одного инстанса
Amazon EC2 вы видите с левой стороны,

00:04:33.840 --> 00:04:36.720
что мы запустили три
различных контейнера.

00:04:36.720 --> 00:04:40.600
Каждый контейнер в себе содержит
не только приложение,

00:04:40.600 --> 00:04:45.400
но и все, что необходимо для корректного
функционирования каждого приложения.

00:04:45.400 --> 00:04:52.000
И при этом вы видите, что приложения работают с
различными библиотеками, не связанные между собой.

00:04:52.000 --> 00:04:56.600
Самое главное, чтобы была
нужная операционная система.

00:04:56.600 --> 00:05:01.320
Здесь необходимо также сделать
пометку, что контейнеры

00:05:01.320 --> 00:05:06.920
достаточно гибкие и могут запускаться
на различных операционных системах.

00:05:06.920 --> 00:05:11.440
Основное требование, чтобы были
все реализованы, все необходимые

00:05:11.440 --> 00:05:18.080
фичи, функционал, который нужен
для конкретного контейнера.

00:05:18.080 --> 00:05:21.880
У нас есть различные варианты
операционной системы Linux.

00:05:21.880 --> 00:05:29.560
В том случае, когда для нашего контейнера нужен
тот функционал, который есть у двух различных

00:05:29.560 --> 00:05:33.360
Linux операционной системы,
мы говорим о том, что этот

00:05:33.360 --> 00:05:39.800
контейнер может успешно запуститься и в первом,
и во втором варианте операционной системы.

00:05:39.800 --> 00:05:48.480
Таким образом, контейнер в том же
состоянии, который есть, вы можете

00:05:48.480 --> 00:05:55.880
запускать на любом другом компьютере на
отличающейся операционной системе.

00:05:55.880 --> 00:06:00.360
И это придает некоторую гибкость
во время работы с контейнерами.

00:06:00.360 --> 00:06:11.960
Другой момент, в рамках одного EC2 инстанса мы
можем запускать очень маленькие контейнеры

00:06:11.960 --> 00:06:19.280
и в одном инстансе EC2 может находиться в один
момент времени сотни различных контейнеров.

00:06:19.280 --> 00:06:25.960
Каждый контейнер обслуживает
какое-то определенное приложение.

00:06:25.960 --> 00:06:34.160
Теперь двигаясь к AWS, вы скорее всего уже
в уме запланировали, что для того,

00:06:34.160 --> 00:06:39.400
чтобы работать с контейнерами, вам необходимо
запустить один Amazon EC2 инстанс,

00:06:39.400 --> 00:06:45.520
там установить docker приложения и
вы можете работать с контейнерами.

00:06:45.520 --> 00:06:54.840
Да, это правильный вариант работы с
контейнерами в облаке, но не самый лучший.

00:06:54.840 --> 00:07:01.560
Самый лучший вариант - это специально созданный
сервис Amazon Elastic Container Service, чаще

00:07:01.560 --> 00:07:11.480
встречается в сокращенном варианте ECS и дает
возможность работать с контейнерами в более

00:07:11.480 --> 00:07:15.560
удобном виде. Таким образом вы
можете запускать до 10 тысяч ваших

00:07:15.560 --> 00:07:21.080
контейнеров за несколько секунд,
используя этот сервис.

00:07:21.080 --> 00:07:25.680
Вы можете также удобно мониторить,
управлять и даже настраивать

00:07:25.680 --> 00:07:31.800
различные действия и расписания для
запуска и управления вашими контейнерами.

00:07:31.800 --> 00:07:38.280
Здесь также следует отметить,
что ECS поддерживает не только

00:07:38.280 --> 00:07:46.360
On-demand EC2 инстансы, а также
Spot Instances и Reserved Instances.

00:07:46.360 --> 00:07:50.640
Давайте рассмотрим пример.
У нас есть некий task definition.

00:07:50.640 --> 00:07:58.480
Task definition это описание вашего контейнера.
В нем содержится информация о вашем приложении,

00:07:58.480 --> 00:08:05.280
какие порты используете, возможно дополнительные
параметры вы задаете для работы приложения.

00:08:05.280 --> 00:08:10.520
И представим, что в этом примере
мы сделали task definition,

00:08:10.520 --> 00:08:16.840
описали два контейнера, Container A и
Container B. Теперь в рамках нашей

00:08:16.840 --> 00:08:24.840
инфраструктуры нам необходимо три инстанса
Container A и два инстанса Container B.

00:08:24.840 --> 00:08:35.440
Таким образом мы делаем task, т.е. задача, либо
instance контейнера, если так можно выразиться.

00:08:35.440 --> 00:08:40.560
Таким образом мы эти маленькие инстансы, в
которых сидят наши контейнеры, через task

00:08:40.560 --> 00:08:50.640
передаем сервис Amazon ECS. И этот сервис для
нас в зависимости от наших дополнительных

00:08:50.640 --> 00:08:59.600
входных данных для сервиса ECS располагает эти
контейнеры и запускает их в нашем кластере ECS.

00:08:59.600 --> 00:09:06.440
Cluster ECS – это набор Amazon EC2
инстансов, которые запущены в виде группы.

00:09:06.440 --> 00:09:13.240
Таким образом, сервис Amazon ECS устанавливает
на каждом Amazon EC2 инстансе агент.

00:09:13.240 --> 00:09:19.560
Этот агент как раз таки помогает вам располагать
ваши контейнеры внутри этих Amazon EC2 инстансов.

00:09:19.560 --> 00:09:27.200
Когда мы говорим про ECS кластер
для нас доступны три варианта.

00:09:27.200 --> 00:09:39.020
Первый вариант – когда создаем наши контейнеры
и описываем дополнительные параметры какой

00:09:39.020 --> 00:09:43.520
мощности должен быть этот контейнер,
в каком количестве мы эти контейнеры создаем,

00:09:43.520 --> 00:09:51.120
а также необходимые параметры для настройки сети
и взаимодействия этих контейнеров между собой,

00:09:51.120 --> 00:09:59.440
т.е. Networking Related Settings. В этом
случае мы говорим про кейс с правой стороны

00:09:59.440 --> 00:10:07.480
и благодаря связке сервисов
Amazon ECS и сервиса AWS Fargate

00:10:07.480 --> 00:10:10.440
мы можем сконцентрироваться
лишь на наших контейнерах.

00:10:10.440 --> 00:10:17.080
Все остальное, т.е. управление операционной
системы, управление docker-агентом, также

00:10:17.240 --> 00:10:24.400
docker-приложением, где запускаются и работают
наши контейнеры, передается под управление AWS.

00:10:24.400 --> 00:10:33.480
Это в случае, если у вас нет ресурсов либо
специалистов или нет необходимости какой-то супер

00:10:33.500 --> 00:10:38.680
тонкой настройки ваших Amazon EC2 инстансов,
где запущены ваши контейнеры.

00:10:38.680 --> 00:10:47.360
В случае же если вам нужна какая-то тонкая
подвинутая настройка она не всегда необходима.

00:10:47.360 --> 00:10:54.560
Но в этом случае вы можете воспользоваться другим
вариантом слева, когда вы полностью контролируете

00:10:54.560 --> 00:11:01.760
и инстансы в рамках ECS кластера и указываете
все необходимые более тонкие настройки.

00:11:01.760 --> 00:11:03.240
В этом случае есть два варианта.

00:11:03.240 --> 00:11:10.960
Ваш ECS кластер будет состоять из
EC2 инстансов либо Linux, либо Windows.

00:11:10.960 --> 00:11:18.520
И в том и в этом случае, помимо того, что вы
делаете в первом варианте, вам также необходимо

00:11:18.520 --> 00:11:25.840
ввести все настройки, которые необходимы
для создания одного Amazon EC2 инстанса.

00:11:25.840 --> 00:11:35.400
Используя этот шаблон ваших входных
данных, уже будет создаваться ECS кластер.

00:11:35.400 --> 00:11:37.800
Давайте представим следующий кейс.

00:11:37.800 --> 00:11:44.640
Вы компания, разрабатываете некоторое приложение
и для этого используете docker-контейнеры.

00:11:44.640 --> 00:11:50.240
Компания растет, через некоторое время количество
ваших контейнеров увеличивается.

00:11:50.240 --> 00:11:55.760
И вам нужно что-то, что помогло бы
вам эффективно оркестрировать,

00:11:55.760 --> 00:11:58.880
то есть управлять вот этот
большой объем ваших контейнеров.

00:11:58.880 --> 00:12:05.560
Для этого было создано open source software
специально для container orchestration,

00:12:05.560 --> 00:12:10.360
называется Kubernetes, либо вы
можете чаще встречать как K8S.

00:12:10.360 --> 00:12:18.480
Чтобы понять, что такое Kubernetes, когда мы
говорим про docker, мы говорим, что как гостевая

00:12:18.540 --> 00:12:24.580
операционная система, мы работаем в рамках
одной гостевой операционной системы.

00:12:24.680 --> 00:12:28.760
Когда мы говорим про Kubernetes,
мы уже поднимаемся на уровень

00:12:28.860 --> 00:12:31.480
выше и работаем уже
с несколькими Docker host-ами.

00:12:31.480 --> 00:12:40.800
Kubernetes нам позволяет
упростить задачи масштабирования,

00:12:40.800 --> 00:12:45.000
container provisioning, т.е.
запуска наших контейнеров, вопросы

00:12:45.000 --> 00:12:50.560
связанные с networking, а также
распределением нагрузки,

00:12:50.560 --> 00:12:53.200
т.е. это то решение, которое
нам помогает эффективно

00:12:53.200 --> 00:12:59.440
справляться с этим большим количеством
разнородных контейнеров.

00:12:59.440 --> 00:13:05.200
Когда мы говорим про Kubernetes, также
есть некоторые популярные термины.

00:13:05.200 --> 00:13:14.360
Kubernetes управляет кластером. Cluster – это
набор нескольких виртуальных машин.

00:13:14.360 --> 00:13:19.920
Каждая виртуальная машина в рамках
кластера называется нодой.

00:13:19.920 --> 00:13:27.920
Мы помним, что в рамках одной виртуальной машины
может запускаться несколько сотен контейнеров.

00:13:27.920 --> 00:13:36.000
Так вот, в нашем случае, в случае
Kubernetes, как контейнер выступают поды.

00:13:36.000 --> 00:13:39.800
Таким образом у нас
кластер состоит из нодов,

00:13:39.800 --> 00:13:47.840
и в каждой ноде может запускаться большое
количество подов, т.е. контейнеров.

00:13:47.840 --> 00:13:53.880
Мы двигаемся дальше. Теперь
поговорим про следующий сервис.

00:13:53.880 --> 00:13:59.520
Вы, наверное, подумали, что вы сейчас можете
поднять кластер Kubernetes следующим образом.

00:13:59.520 --> 00:14:03.920
Запускаете несколько Amazon EC2 инстансов,
устанавливаете docker-приложение, поверх

00:14:03.920 --> 00:14:09.600
устанавливаете Kubernetes-приложение, и у вас
Kubernetes-кластер, с которым вы можете работать.

00:14:09.600 --> 00:14:17.520
Да, это действительно так, это один из вариантов,
но когда мы работаем с AWS, у нас есть вариант

00:14:17.520 --> 00:14:24.000
получше, а именно сервис Amazon Elastic Kubernetes
Service, чаще вы будете встречать как Amazon ЕKS.

00:14:24.000 --> 00:14:27.920
Это тот сервис, который предоставляет
нам Managed Kubernetes Service,

00:14:27.920 --> 00:14:32.400
т.е. это тот сервис, который
полностью совместим с приложением

00:14:32.400 --> 00:14:41.000
Kubernetes, и сервис
позволяет пользователям, клиентам

00:14:41.000 --> 00:14:45.780
нашего облачного провайдера
AWS разгрузиться, и большую

00:14:45.780 --> 00:14:50.000
часть операционной деятельности
по обслуживанию этого

00:14:50.000 --> 00:14:55.800
кластера передать AWS, а самим больше
сконцентрироваться на бизнес-задачах.

00:14:55.800 --> 00:15:01.840
То, что этот сервис совместим
с приложением Kubernetes, говорит

00:15:01.840 --> 00:15:08.240
о том, что мы наши уже запущенные
на локальном дата-центре

00:15:08.240 --> 00:15:12.120
нагрузки на Kubernetes можем
с легкостью перенести на AWS,

00:15:12.120 --> 00:15:18.160
а именно в сервис Amazon
Elastic Kubernetes Service.

00:15:18.160 --> 00:15:26.880
У вас может возникнуть вопрос «Чем же все-таки
отличаются сервисы Amazon ECS и Amazon ЕKS?».

00:15:26.880 --> 00:15:34.920
На самом деле оба сервиса помогают нам
оркестрировать нашим кластером Docker-контейнеров.

00:15:34.920 --> 00:15:38.300
Отличие лишь в том, что в первом
случае мы работаем непосредственно

00:15:38.300 --> 00:15:47.400
с Docker-контейнерами и управляем нашим
кластером посредством сервиса AWS.

00:15:47.400 --> 00:15:52.880
Когда мы говорим про ЕKS,
оркестрацием кластера уже

00:15:52.880 --> 00:16:00.480
занимается не решением от AWS,
а open sourсe программа Kubernetes,

00:16:00.480 --> 00:16:06.840
но она обернута в сервис, который нас
разгружает от некоторых операционных моментов.

00:16:06.840 --> 00:16:14.400
Они похожи в зависимости от
того, что у вас установлено,

00:16:14.400 --> 00:16:18.040
как ваша инфраструктура
поднята, как она функционирует,

00:16:18.040 --> 00:16:21.320
либо если сейчас вы ни то,
ни другое не используете,

00:16:21.320 --> 00:16:27.880
то как минимум у клиентов AWS есть
возможность выбрать один из этих вариантов.

00:16:27.880 --> 00:16:33.560
Следующий сервис, о котором я хотел вам
рассказать, это Amazon Elastic Container

00:16:33.560 --> 00:16:36.280
Registry, чаще вы его будете
встречать как Amazon ECR.

00:16:36.280 --> 00:16:41.540
Это тот сервис, который является
хранилищем всех ваших Docker-образов.

00:16:41.540 --> 00:16:51.200
Таким образом, когда вы создаете кластер, неважно
с использованием сервиса Amazon ECS, либо

00:16:51.200 --> 00:16:58.240
сервиса Amazon ЕKS, вам необходимо указать
ваш контейнер, образ этого контейнера.

00:16:58.240 --> 00:17:02.560
В этом случае необходимо
воспользоваться сервисом Amazon ECR.

00:17:02.560 --> 00:17:05.800
Как аналогия могу привести,
когда мы с вами создаем

00:17:05.800 --> 00:17:12.360
Amazon EC2 инстанс, мы указываем AMI,
т.е. образ вашего будущего инстанса.

00:17:12.360 --> 00:17:19.800
AMI в этом случае
выступает как Docker-образ.

00:17:19.800 --> 00:17:29.400
И хранилище всех ваших AMI в случае с
контейнерами – это сервис Amazon ECR.

00:17:29.400 --> 00:17:34.720
Мы с вами добрались до конца четвертой секции.
Давайте пройдемся по самым основным моментам.

00:17:34.720 --> 00:17:44.520
Контейнеры – это нечто, что может в себе хранить
все необходимое для успешного запуска вашего

00:17:44.520 --> 00:17:48.800
приложения. Сюда входят библиотеки,
системные настройки, код и так далее.

00:17:48.800 --> 00:17:56.040
Docker – это та программа, которая
позволяет вам создавать контейнеры.

00:17:56.040 --> 00:18:04.800
Это одна из самых популярных программ для этого.
Одно приложение может запускаться в нескольких

00:18:04.800 --> 00:18:10.680
контейнерах, связанных между собой.
Есть сервис Amazon Elastic Container Service,

00:18:10.740 --> 00:18:19.880
т.е. ECS, который позволяет вам
оркестрировать вашими Docker-контейнерами.

00:18:19.880 --> 00:18:25.880
Следующее популярное приложение,
программа – это Kubernetes.

00:18:25.880 --> 00:18:31.640
Это open source решение, которое позволяет
вам оркестрировать ваши контейнеры.

00:18:31.640 --> 00:18:36.920
Специально для Kubernetes был создан отдельный
сервис Amazon Elastic Kubernetes Service.

00:18:36.920 --> 00:18:42.640
Он совместим с Kubernetes
и позволяет вам разгрузиться

00:18:42.640 --> 00:18:48.440
от операционной работы,
но при этом управлять вашим

00:18:48.440 --> 00:18:52.640
кластером Docker-контейнеров
через Kubernetes.

00:18:52.640 --> 00:18:56.680
И третий сервис это Amazon
Elastic Container Registry.

00:18:56.680 --> 00:19:04.440
Это сервис, который является хранилищем
всех ваших Docker-контейнеров.

00:19:04.440 --> 00:19:09.280
Мы с вами добрались до пятой секции и
здесь мы поговорим про сервис AWS Lambda.

00:19:09.280 --> 00:19:17.360
Это мой самый любимый сервис внутри всех
сервисов AWS и сейчас вы узнаете почему.

00:19:17.360 --> 00:19:21.640
Мы с вами ранее проговаривали,
что у нас есть различные

00:19:21.640 --> 00:19:27.040
сервисы, которые предоставляют
различные IT-ресурсы.

00:19:27.040 --> 00:19:34.200
Когда мы говорим про Compute, Amazon EC2
сервис предоставляет нам виртуальные машины.

00:19:34.200 --> 00:19:38.320
Сервисы Amazon ECS и Amazon EKS
помогают нам работать с контейнерами.

00:19:38.320 --> 00:19:42.640
Так вот, следующий уровень – это
AWS Lambda, Serverless Computing,

00:19:42.640 --> 00:19:54.020
т.е. это сервис, который исключает абсолютно все
операционные задачи под вас и достаточно вам ваш

00:19:54.020 --> 00:20:02.720
код загрузить в этот сервис. Все что связано
с запуском этого сервиса, поддержкой,

00:20:02.720 --> 00:20:08.040
настройкой мониторинга и так далее
занимается и берет на себя AWS.

00:20:08.040 --> 00:20:15.040
Таким образом, я как разработчик
могу исключить необходимость

00:20:15.040 --> 00:20:19.820
системного администратора при
построении какого-то решения.

00:20:19.820 --> 00:20:27.640
Также и вы, так как IT университеты
больше выпускают разработчиков,

00:20:27.640 --> 00:20:31.040
нежели системных администраторов,
вы также можете воспользоваться

00:20:31.040 --> 00:20:34.760
этим сервисом для запуска
своих собственных решений,

00:20:34.760 --> 00:20:39.440
собственных стартап-проектов,
где благодаря AWS исключается

00:20:39.440 --> 00:20:45.120
необходимость целого человека,
специалиста, т.е. системного администратора.

00:20:45.120 --> 00:20:54.800
Это поможет вам сократить некоторые расходы и
увеличить шансы успешного запуска вашего стартапа.

00:20:54.800 --> 00:20:58.760
Касательно оплаты, здесь тоже
очень важный момент.

00:20:58.760 --> 00:21:03.700
Вы оплачиваете за количество времени,
когда AWS Lambda была запущена.

00:21:03.700 --> 00:21:09.720
В случае, когда ваш код не запускается,
вы абсолютно ничего не оплачиваете.

00:21:09.720 --> 00:21:16.000
Это также идеально подходящая
модель оплаты для тех же

00:21:16.000 --> 00:21:19.680
стартапов, либо для тех нагрузок,
которые не постоянны.

00:21:19.680 --> 00:21:23.080
Представьте, вы некий стартап,
у вас нагрузки небольшие,

00:21:23.080 --> 00:21:27.280
потому что вы не наработали
клиентскую базу, вы не настолько

00:21:27.280 --> 00:21:30.680
популярны, таким образом
ваш код будет запускаться

00:21:30.680 --> 00:21:35.360
только в тот момент, когда ваше
приложение будут использовать.

00:21:35.360 --> 00:21:42.320
Если ваше приложение никто не использует,
то вы соответственно ничего не оплачиваете.

00:21:42.320 --> 00:21:47.960
Давайте рассмотрим подробнее, какие есть
преимущества у сервиса AWS Lambda.

00:21:47.960 --> 00:21:51.400
С AWS Lambda вам нет необходимости
изучать новые языки программирования.

00:21:51.400 --> 00:21:54.520
Оно и так изначально поддерживает
самые популярные языки

00:21:54.520 --> 00:22:03.440
программирования, в том числе Python,
JavaScript, Node.js, Ruby, C# и т.д.

00:22:03.440 --> 00:22:10.000
Вы уже поняли, что большую
часть администрирования

00:22:10.000 --> 00:22:17.400
по запуску вашей Lambda-ы берет на себя AWS,
вам необходимо лишь загрузить ваш код.

00:22:17.400 --> 00:22:24.080
Внутри AWS также сидит встроена
защита от падений. Что это значит?

00:22:24.080 --> 00:22:28.800
Это значит, микроконтейнеры,
в котором запускается ваш

00:22:28.800 --> 00:22:33.800
код, находятся в нескольких availability
зонах в рамках региона.

00:22:33.800 --> 00:22:37.040
Таким образом, если что-то происходит
в availability зоне,

00:22:37.040 --> 00:22:40.280
то ваш контейнер запустится
в другой availability зоне.

00:22:40.280 --> 00:22:47.080
Вы этого даже никак не заметите, не узнаете,
оно встроенно сидит внутри AWS Lambda.

00:22:47.080 --> 00:22:56.440
Таким образом, все ваши запросы на
AWS Lambda будут успешно отработаны.

00:22:56.440 --> 00:23:00.340
Бывают некоторые нагрузки,
когда вам необходимо запускать

00:23:00.340 --> 00:23:03.960
несколько AWS Lambda, это какая-то
сложная логика и одна лямбда

00:23:03.960 --> 00:23:06.560
может запускать другую лямбду,
либо в зависимости

00:23:06.560 --> 00:23:09.880
от результатов выполнения
одной лямбды, при некоторых

00:23:09.880 --> 00:23:15.080
дополнительных условиях вы можете
запускать или не запускать другие лямбды.

00:23:15.080 --> 00:23:18.160
Для построения этой сложной
логики, либо оркестрации

00:23:18.160 --> 00:23:25.360
нескольких лямбда-функций, вы можете
воспользоваться сервисом AWS Step Functions.

00:23:25.360 --> 00:23:28.840
AWS Step Functions как раз таки
расписывает эту логику и в зависимости

00:23:28.840 --> 00:23:32.080
от логики она будет
вызывать ту или иную лямбду.

00:23:32.080 --> 00:23:35.600
Но лямбда также может использоваться
отдельно, самостоятельно,

00:23:35.600 --> 00:23:40.720
независимая функция, которая в зависимости от
запроса возвращает какой-то готовый ответ.

00:23:40.720 --> 00:23:45.400
Например, у вас есть веб-сайт и вы
запрашиваете информацию о каком-то продукте.

00:23:45.400 --> 00:23:49.080
Таким образом, когда запрос
прилетает до вашей лямбды,

00:23:49.080 --> 00:23:56.320
лямбда, используя входные
данные, идет в хранилище

00:23:56.320 --> 00:23:59.720
информацию о ваших продуктах
и извлекает необходимую

00:23:59.720 --> 00:24:03.640
информацию, далее возвращает
это в вызывающей стороне.

00:24:03.640 --> 00:24:10.920
Как хранилище у вас может выступить объектное
хранилище в качестве сервиса AWS S3.

00:24:10.920 --> 00:24:18.160
Если у вас SQL база данных,
это сервис AWS RDS, в случае

00:24:18.160 --> 00:24:22.720
если у вас NoSQL база данных,
то у нас есть AWS DynamoDB, т.е.

00:24:22.720 --> 00:24:30.240
вариантов интеграции сервиса AWS Lambda с
другими сервисами имеется большое количество.

00:24:30.240 --> 00:24:34.960
Также немаловажное преимущество
это pay-per-use pricing,

00:24:34.960 --> 00:24:39.240
т.е. вы оплачиваете только за то время,
когда ваша лямбда была запущена.

00:24:39.240 --> 00:24:48.000
Это позволяет значительно сэкономить ваши
затраты, если ваши нагрузки не постоянны.

00:24:48.000 --> 00:24:56.400
Давайте поговорим о самых популярных сервисах,
которые работают в связке с AWS Lambda.

00:24:56.400 --> 00:25:02.880
Когда мы говорим про объектное хранилище,
самым популярным вариантом является Amazon S3.

00:25:02.880 --> 00:25:07.640
Он нативно интегрируется с этим сервисом
и никаких проблем не возникает.

00:25:07.640 --> 00:25:13.460
Другой вариант, когда говорим, что нам необходимо
хранить некоторые данные в не структурированном

00:25:13.460 --> 00:25:19.880
виде, нам необходимо использовать NoSQL баз
данных. В этом случае выступает Amazon DynamoDB.

00:25:19.880 --> 00:25:26.760
Amazon DynamoDB является также
serverless решением баз данных NoSQL.

00:25:26.760 --> 00:25:33.000
Таким образом, она также нативно
интегрирована с сервисом AWS Lambda.

00:25:33.000 --> 00:25:40.640
Далее у нас есть два сервиса
Amazon SNS, а также Amazon SQS.

00:25:40.640 --> 00:25:53.760
Amazon SNS – когда в зависимости от условий
можем в формате Push отправлять уведомления.

00:25:53.760 --> 00:26:03.240
Когда мы говорим SQS, это работа с очередью
и нагрузки формата Pull, т.е. в случае

00:26:03.240 --> 00:26:12.640
Amazon SNS мы передаем какое-то сообщение, а оно
сразу отправляется, push-ится к получателям.

00:26:12.640 --> 00:26:17.960
Когда мы говорим Amazon SQS, это pull, т.е. в
Amazon SQS в очереди накапливается определенное

00:26:17.960 --> 00:26:21.360
количество сообщений и мы в
режиме pull, т.е. подтягиваем

00:26:21.360 --> 00:26:26.840
необходимый объем сообщений для обработки
в тот момент, когда нам это нужно.

00:26:26.840 --> 00:26:34.880
Это два варианта построения архитектуры в облаке
и оба варианта также интегрированы с AWS Lambda.

00:26:34.880 --> 00:26:38.720
Когда мы говорим, что нам
необходимо построить API,

00:26:38.720 --> 00:26:45.360
т.е. Application Program Interface, мы можем
интегрировать AWS Lambda с Amazon API Gateway.

00:26:45.360 --> 00:26:51.240
Это одна из самых популярных
связок AWS Lambda.

00:26:51.240 --> 00:26:58.800
Еще один существующий, но менее популярный
вариант сервиса – это Application Load Balancer.

00:26:58.800 --> 00:27:07.080
Например, представьте, у вас есть кластер EC2,
он запускается, делает некоторые нагрузки,

00:27:07.080 --> 00:27:11.480
но при этом вы знаете, что после
восьми часов вечера вам смело

00:27:11.480 --> 00:27:23.240
можно отключать 50% ваших EC2 инстанcов,
потому что нагрузка резко уменьшается.

00:27:23.240 --> 00:27:29.000
В этом случае вы можете настроить Event,
который триггерит вашу лямбду

00:27:29.000 --> 00:27:35.120
в 8 часов вечера, дальше AWS Lambda
уже передает запрос на сервис

00:27:35.120 --> 00:27:46.720
Application Load Balancer, который сокращает
количество инстанcов Amazon EC2.

00:27:46.720 --> 00:27:49.840
Давайте теперь подробнее
поговорим о том, какие

00:27:49.840 --> 00:27:54.680
настройки необходимо произвести
для запуска нашей лямбда-функции.

00:27:54.680 --> 00:27:59.600
Самое первое, нам нужен код программы,
который будет запускаться.

00:27:59.600 --> 00:28:06.000
Далее нам необходимо настроить
IAM role для лямбда-функции.

00:28:06.000 --> 00:28:10.460
Если вы создаете лямбда-функцию
в AWS Management Console, то для вас

00:28:10.460 --> 00:28:15.240
создается role с минимальными
правами, а именно с правами

00:28:15.240 --> 00:28:20.560
для сервиса AWS CloudWatch, чтобы функция
могла писать туда свои логи отработки.

00:28:20.560 --> 00:28:25.520
Если вам необходимо, чтобы лямбда-функция
работала с другими AWS сервисами,

00:28:25.520 --> 00:28:31.280
вам необходимы соответствующие policy,
права, доступы добавить в эту role.

00:28:31.280 --> 00:28:40.560
Также нам необходимо указать
Run time, т.е. в какой среде

00:28:40.560 --> 00:28:45.360
запускать код, либо это
Python, Node.js, C# и т.д.

00:28:45.360 --> 00:28:54.080
Помимо самого кода AWS Lambda, мы также
можем использовать другие зависимости.

00:28:54.080 --> 00:29:02.800
Это могут быть дополнительные кастомные
библиотеки, необходимые для запуска вашего кода.

00:29:02.800 --> 00:29:14.120
В этом случае вам необходимо создать архив
и этот архив загружать в сервисы AWS Lambda.

00:29:14.120 --> 00:29:18.600
В случае, когда вы не используете
дополнительные библиотеки,

00:29:18.600 --> 00:29:21.600
библиотеки достаточно редко
используются и в случае

00:29:21.600 --> 00:29:26.420
Python, стандартных библиотек Python
хватает для большинства задач.

00:29:26.420 --> 00:29:38.040
В этом случае у нас есть только код программы
и вы можете работать в консоли AWS Lambda-ы

00:29:38.040 --> 00:29:43.720
и копировать, вставлять код и сохранять этот
код в этой же странице, что очень удобно.

00:29:43.720 --> 00:29:54.520
Касательно времени запуска, функция максимум
может запускаться 15 минут, т.е. 900 секунд.

00:29:54.520 --> 00:30:01.280
Больше этого она запускаться не может. В случае,
если вам нужно больше времени, вам необходимо

00:30:01.280 --> 00:30:07.800
рассмотреть вариант использования
Step Functions, когда одна лямбда

00:30:07.800 --> 00:30:14.160
запускает следующую лямбду, таким образом вы
получаете дополнительные 15 минут запуска.

00:30:14.160 --> 00:30:17.700
В случае, если этот вариант
вам не подходит, вы можете

00:30:17.700 --> 00:30:22.080
также посмотреть в сторону контейнеров,
либо в сторону инстанcов EC2.

00:30:22.080 --> 00:30:26.040
В зависимости от вашей бизнес-задачи
тот или иной вариант может

00:30:26.040 --> 00:30:33.240
быть вам ближе либо выгоден
с точки зрения реализации.

00:30:33.240 --> 00:30:38.280
Когда мы говорим о мощности нашей
функции, то мы контролируем

00:30:38.280 --> 00:30:41.720
количество оперативной памяти,
которую мы можем ей выделить.

00:30:41.720 --> 00:30:52.960
Мы можем выдать минимально 128 МБ для этой
функции, либо до 10 ГБ оперативной памяти.

00:30:52.960 --> 00:31:01.720
Количество ядер будет увеличиваться пропорционально
увеличению количества оперативной памяти.

00:31:01.720 --> 00:31:10.160
Ее мы отдельно от оперативной
памяти устанавливать не можем.

00:31:10.160 --> 00:31:16.320
Давайте рассмотрим пример использования
AWS Lambda, достаточно популярный пример.

00:31:16.320 --> 00:31:22.680
У нас есть наборы EC2 инстанcов
и в зависимости от наших

00:31:22.680 --> 00:31:27.320
нагрузок мы понимаем, что в
10 часов вечера мы можем

00:31:27.320 --> 00:31:33.680
отключать все наши инстансы, а в 5 часов утра
нам необходимо стартовать наши инстансы.

00:31:33.680 --> 00:31:39.800
Как мы можем настроить нашу архитектуру
для того, чтобы это все работало.

00:31:39.800 --> 00:31:45.760
Мы создаем два event-a. Эти event-ы
создаются в сервисе AWS CloudWatch.

00:31:45.760 --> 00:31:52.720
Первый event по расписанию в 10 часов
вечера будет триггерить первую лямбду.

00:31:52.720 --> 00:31:58.200
Эта лямбда на вход принимает этот event. Также
в этой лямбде либо в event-е мы можем прописать

00:31:58.200 --> 00:32:04.680
список инстанcов на отключение и в момент
запуска лямбды у нее есть соответствующая rоle.

00:32:04.680 --> 00:32:09.120
У этой rоle есть права для
отключения из этого инстансов.

00:32:09.120 --> 00:32:13.640
Она запускает соответствующие команды
и наши инстансы отключаются.

00:32:13.640 --> 00:32:23.000
Второй event по расписанию триггерит
в 5 часов утра уже другую вторую лямбду.

00:32:23.000 --> 00:32:26.360
У этой лямбды есть соответствующая
либо та же rоle, либо другая

00:32:26.360 --> 00:32:30.440
rоle, у которой есть права
на запуск инстансов.

00:32:30.440 --> 00:32:40.040
В момент триггера event-ом AWS CloudWatch нашей
лямбда-функции она исполняет свой код и в

00:32:40.040 --> 00:32:48.880
зависимости от входных данных списка
инстанcов эти инстанcы стартует.

00:32:48.880 --> 00:32:54.920
Давайте теперь рассмотрим второй пример.
Представим, что у нас есть некоторое приложение,

00:32:54.920 --> 00:33:02.440
которое в себе содержит фотографии. Наш
пользователь загружает некоторую фотографию.

00:33:02.440 --> 00:33:06.200
Эта фотография у нас сохраняется
в Amazon S3 bucket.

00:33:06.200 --> 00:33:10.840
Далее, как только у нас файл
загрузился в Amazon S3 bucket,

00:33:10.840 --> 00:33:16.160
запускается event, который
триггерит нашу лямбду.

00:33:16.160 --> 00:33:19.600
Запускается наша лямбда, в event-е
сидят входные данные, а в том числе

00:33:19.600 --> 00:33:27.720
информация с ссылкой на эту картинку. Мы
понимаем какая картинка была загружена.

00:33:27.720 --> 00:33:32.520
Далее лямбда использует свою rоle,
у нее есть соответствующие права.

00:33:32.520 --> 00:33:39.800
Она загружает эту картинку, обрабатывает ее и
создает эту же картинку в различных разрешениях.

00:33:39.800 --> 00:33:47.800
В том числе и картинку так называемую thumbnail.
Это мини версия этой картинки, которая весит

00:33:47.800 --> 00:33:54.080
очень мало, при этом эта картинка отображается,
когда мы видим наши картинки в списке.

00:33:54.080 --> 00:34:00.720
Далее после отработки,
подготовки всех необходимых

00:34:00.720 --> 00:34:06.520
картинок, она загружает уже эти
картинки в другой Amazon S3 bucket.

00:34:06.520 --> 00:34:13.880
И если додумывать дальше,
то приложение уже может

00:34:13.880 --> 00:34:17.240
отображать другим пользователям
список этих фотографий

00:34:17.240 --> 00:34:20.840
в различных разрешениях,
а также может использовать

00:34:20.840 --> 00:34:30.320
thumbnail для отображения мини версии при
просмотре списка всех наших картинок.

00:34:30.320 --> 00:34:35.560
Давайте подробнее остановимся на
основных лимитах сервиса AWS Lambda.

00:34:35.560 --> 00:34:42.160
Здесь хотел бы также отметить, большинство
лимитов являются soft и могут быть увеличены

00:34:42.160 --> 00:34:48.240
по обращению в AWS support. В рамках одного
региона можно запускать параллельно

00:34:48.240 --> 00:34:54.560
до 1000 execution-ы Lambda.
Представим, что у вас есть определенная

00:34:54.560 --> 00:34:58.360
функция, она передает информацию
о каком-то продукте и

00:34:58.360 --> 00:35:02.720
в случае, если внезапно 1000
пользователей запросят

00:35:02.720 --> 00:35:05.760
информацию о некотором
продукте и вам необходимо

00:35:05.760 --> 00:35:10.600
параллельно запустить 1000 лямбд,
то AWS на своей стороне

00:35:10.600 --> 00:35:14.880
автоматически создаст микроконтейнеры,
где запускаются ваши

00:35:14.880 --> 00:35:21.960
лямбды в необходимом количестве до 1000
и успешно запустит все эти лямбды.

00:35:21.960 --> 00:35:27.760
Далее, если количество запросов
резко уменьшится, то все запущенные

00:35:27.760 --> 00:35:34.240
микроконтейнеры будут постепенно
уничтожаться по внутренней логике AWS.

00:35:34.240 --> 00:35:37.920
В случае, если у вас придет больше
запросов, то вы можете

00:35:37.920 --> 00:35:44.640
настроить retry логику и ваш запрос будет
через некоторое время отправлен еще раз.

00:35:44.640 --> 00:35:48.840
Так как на тот момент уже
будет скорее всего запускаться

00:35:48.840 --> 00:35:55.120
меньшее количество лямбд, то эти
запросы тоже будут успешно обработаны.

00:35:55.120 --> 00:36:04.280
Если мы говорим про размер нашей функции, включая
код, а также все необходимые библиотеки для

00:36:04.280 --> 00:36:12.520
запуска, то оно может быть размером до 250
мегабайтов в не архивированном состоянии.

00:36:12.520 --> 00:36:19.600
Если мы говорим про мощность лямбды,
то мы можем выделить минимум 128 мегабайтов

00:36:19.600 --> 00:36:28.800
оперативной памяти и максимум 10 гигабайтов
оперативной памяти для одной нашей функции.

00:36:28.800 --> 00:36:32.360
Здесь следует отметить,
что количество ядер процессора

00:36:32.360 --> 00:36:41.320
будет выделяться параллельно количеству
выделенных мегабайтов оперативной памяти.

00:36:41.320 --> 00:36:51.920
Если мы говорим про максимальную длительность
запуска одной функции, то это 900 сек либо 15 мин.

00:36:51.920 --> 00:36:57.640
Мы с вами добрались до конца пятой секции.
Давайте пройдемся по самым основным моментам.

00:36:57.640 --> 00:37:04.560
AWS Lambda – это тот сервис, который
предоставляет нам бессерверные мощности.

00:37:04.560 --> 00:37:10.120
Идея в том, что мы не менеджим наши
серверы, а лишь загружаем наш код.

00:37:10.120 --> 00:37:16.760
Все, что относится к обслуживанию запуска
этого кода, оно происходит на стороне AWS.

00:37:16.760 --> 00:37:24.640
Также AWS Lambda включает автоматическое
масштабирование, т.е. если внезапно происходит

00:37:24.640 --> 00:37:31.280
всплеск запросов на нашу лямбду, то все эти
запросы параллельно будут обработаны.

00:37:31.280 --> 00:37:37.440
AWS Lambda может быть достаточно
мощной и мы можем выделять

00:37:37.440 --> 00:37:42.520
до 10 гигабайтов оперативной
памяти для одной нашей функции.

00:37:42.520 --> 00:37:48.000
Более того, каждая наша лямбда
может запускаться максимум 15 минут.

00:37:48.000 --> 00:37:51.960
Этого времени более чем достаточно
для выполнения большинства задач.

00:37:51.960 --> 00:38:01.040
На этом мы остановились на самых основных
моментах, связанных с сервисом AWS Lambda.

00:38:01.040 --> 00:38:07.800
Я очень надеюсь, что этот сервис вам пригодится
в будущем при построении ваших стартапов.

00:38:07.800 --> 00:38:12.560
Это идеальный выбор для запуска
чего-либо в облаке.

00:38:12.560 --> 00:38:19.560
И также никогда не забывайте, что нельзя
сильно привязываться к AWS Lambda.

00:38:19.560 --> 00:38:28.280
И бывают ситуации, когда нужно ваши нагрузки,
которые стали постоянными, переносить уже на

00:38:28.280 --> 00:38:31.080
другие мощности. Но когда мы
говорим про самое начало, когда

00:38:31.080 --> 00:38:36.080
ничего не понятно, ничего
не известно, то все serverless

00:38:36.080 --> 00:38:41.920
сервисы, начиная от AWS Lambda,
заканчивая другими сервисами,

00:38:41.920 --> 00:38:45.520
работающими в связке с этой лямбдой,
являются идеальным решением.

00:38:45.520 --> 00:38:54.560
На этом мы с вами добрались до шестой последней
секции в рамках нашей сегодняшней лекции.

00:38:54.560 --> 00:39:01.600
И мы с вами поговорим подробнее
про сервис AWS Elastic Beanstalk.

00:39:01.600 --> 00:39:05.960
AWS Elastic Beanstalk является
следующим примером Compute сервиса,

00:39:05.960 --> 00:39:09.680
предоставляется в форме PaaS,
т.е. Platform as a Service.

00:39:09.680 --> 00:39:14.080
Идея в том, что вы загружаете код вашего
веб-приложения, AWS Elastic Beanstalk

00:39:14.080 --> 00:39:20.080
поднимает всю необходимую инфраструктуру
для того, чтобы запустить это веб-приложение.

00:39:20.080 --> 00:39:28.720
Что подразумевается под "поднять инфраструктуру",
это фактически развертывание вашего веб-приложения,

00:39:28.720 --> 00:39:33.280
настройка балансирования нагрузки,
а также автоматического масштабирования

00:39:33.280 --> 00:39:39.160
и все необходимое связанное с мониторингом
и логированием вашего веб-приложения.

00:39:39.160 --> 00:39:44.120
Здесь следует отметить, что
использование этого сервиса

00:39:44.120 --> 00:39:49.320
является бесплатным, т.е. вы
ни доллара не оплачиваете.

00:39:49.320 --> 00:39:57.320
Но все те ресурсы, которые
были подняты в рамках сервиса

00:39:57.320 --> 00:40:00.840
AWS Elastic Beanstalk, оплачиваются
по стандартным тарифам.

00:40:00.840 --> 00:40:04.880
Например, если вы передали
некоторые входные параметры

00:40:04.880 --> 00:40:09.280
в сервис AWS Elastic Beanstalk
и для вас была поднята инфраструктура

00:40:09.280 --> 00:40:12.800
с двумя Amazon EC2 инстансами,
то вы будете оплачивать

00:40:12.800 --> 00:40:16.840
за эти два инстанса по
стандартному тарифу этого сервиса.

00:40:16.840 --> 00:40:22.000
Это и относится ко всем
другим IT-ресурсам и другим

00:40:22.000 --> 00:40:25.800
сервисам AWS, с которыми
взаимодействует AWS Elastic Beanstalk,

00:40:25.800 --> 00:40:33.720
т.е. вы бы столько же денег заплатили бы, если
бы вы поднимали те же два инстанса вручную.

00:40:33.720 --> 00:40:39.800
Разница лишь в том, что поднятие
инфраструктуры было проделано

00:40:39.800 --> 00:40:45.600
вместо вас, для вас, автоматически
через сервис AWS Elastic Beanstalk.

00:40:45.600 --> 00:40:50.600
Фактически вы оплачиваете ту
же сумму, плюс ко всему

00:40:50.600 --> 00:40:55.760
этому экономите свое время и поднимаете
инфраструктуру автоматически.

00:40:55.760 --> 00:41:04.480
Здесь можно наглядно видеть, какую часть работы
AWS через сервис Elastic Beanstalk берет на себя.

00:41:04.480 --> 00:41:11.120
т.е. то, что вы управляете, это ваш код
и ваши настройки для AWS Elastic Beanstalk.

00:41:11.120 --> 00:41:17.560
Все остальное управляется AWS, HTTP-сервер,
application server, language interpreter,

00:41:17.560 --> 00:41:22.000
т.е. среда запуска вашего
кода, операционная система и даже host.

00:41:22.000 --> 00:41:29.120
Вы можете использовать AWS Elastic
Beanstalk как в AWS Management Console,

00:41:29.120 --> 00:41:36.720
также вы можете использовать AWS CLI для запуска
инфраструктуры с помощью Elastic Beanstalk.

00:41:36.720 --> 00:41:40.160
Когда мы говорим про поддержку
платформ, то поддерживаются

00:41:40.160 --> 00:41:48.000
Docker, Go, Java,.NET, Node.js, PHP,
Python и Ruby и другие платформы.

00:41:48.000 --> 00:41:52.640
Если мы говорим про веб-серверы, которые
поддерживаются, то для Java приложений

00:41:52.640 --> 00:42:00.680
поддерживается Apache Tomcat, для PHP и Python
приложения поддерживается Apache HTTP Server.

00:42:00.680 --> 00:42:07.840
Если мы говорим про Node.js приложения,
для них доступны NGINX и Apache HTTP Server.

00:42:07.840 --> 00:42:15.640
Если Ruby приложения, то это Passenger и Puma.
Если мы говорим про .NET приложения, Java

00:42:15.640 --> 00:42:25.960
и Docker вместе с Go, то поддерживается
Microsoft Internet Information Services, т.е. IIS.

00:42:25.960 --> 00:42:31.120
Давайте остановимся на основных преимуществах
сервиса AWS Elastic Beanstalk.

00:42:31.120 --> 00:42:34.520
Первое это то, что вы очень
быстро и просто можете

00:42:34.520 --> 00:42:37.200
начать, то есть запустить ваше
веб-приложение, поднимается

00:42:37.200 --> 00:42:44.000
вся необходимая инфраструктура, вы фактически
меньше времени теряете на все это дело.

00:42:44.000 --> 00:42:47.760
Другой момент это то, что ваши
специалисты, ваши разработчики

00:42:47.760 --> 00:42:55.120
освобождаются от операционной деятельности
и могут сконцентрироваться на бизнес-задачах.

00:42:55.120 --> 00:42:59.280
Таким образом, эффективность
ваших разработчиков повышается.

00:42:59.280 --> 00:43:04.400
Другой момент это то, что AWS Elastic Beanstalk
подходит для большинства веб-приложений.

00:43:04.400 --> 00:43:14.960
Таким образом, очень редко, когда возможности
AWS Elastic Beanstalk для веб-приложения

00:43:14.960 --> 00:43:22.480
становятся мало и в большинстве случаев вам
будет достаточно сервиса AWS Elastic Beanstalk.

00:43:22.480 --> 00:43:35.920
Другой момент это то, что в Elastic Beanstalk вы
можете достаточно гибко настроить ваши ресурсы.

00:43:35.920 --> 00:43:40.240
Как пример, вы можете указать
определенный instance type в рамках

00:43:40.240 --> 00:43:44.920
сервиса Amazon EC2, который может
поднимать Elastic Beanstalk для вас.

00:43:44.920 --> 00:43:53.000
На этом мы подошли к концу шестой секции.
Давайте остановимся на основных моментах.

00:43:53.000 --> 00:43:58.320
В случае, когда у вас веб-приложение,
то обязательно следует

00:43:58.320 --> 00:44:02.480
рассмотреть сервис AWS Elastic Beanstalk,
так как она помогает

00:44:02.480 --> 00:44:08.200
вам упростить процесс развертывания
вашей IT-инфраструктуры в облаке.

00:44:08.200 --> 00:44:11.520
AWS Elastic Beanstalk поддерживает
достаточно большой выбор

00:44:11.520 --> 00:44:18.480
платформ — это Java, .NET, PHP, Node.js,
Python, Ruby, Go, Docker и другие.

00:44:18.480 --> 00:44:21.280
Если мы говорим касательно оплаты,
этот сервис полностью

00:44:21.280 --> 00:44:28.400
бесплатный для клиентов AWS и вы не
оплачиваете за использование этого сервиса.

00:44:28.400 --> 00:44:35.840
Но вам необходимо оплачивать по стандартным
тарифам за те сервисы, где вы создаете ресурсы.

00:44:35.840 --> 00:44:39.000
Например, если AWS Elastic Beanstalk
поднимает Amazon EC2 инстансы,

00:44:39.000 --> 00:44:47.640
то да, вы будете оплачивать за использование
этих инстансов в рамках стандартных тарифов.

00:44:47.640 --> 00:44:53.040
На этом мы подошли к концу нашей сессии.
Давайте остановимся на самых основных моментах.

00:44:53.040 --> 00:45:00.360
За эти две лекции мы с вами рассмотрели, какие
сервисы вычисления для нас доступны в AWS.

00:45:00.360 --> 00:45:03.680
Мы подробнее познакомились
с сервисом Amazon EC2.

00:45:03.680 --> 00:45:09.680
Далее мы посмотрели, какие сервисы есть,
когда мы работаем с контейнерами.

00:45:09.680 --> 00:45:20.600
Это Amazon EKS, Amazon ECS и Amazon ECR.
Далее познакомились с serverless решением.

00:45:20.600 --> 00:45:25.120
Это AWS Lambda. Рассмотрели,
какие есть плюсы и минусы.

00:45:25.120 --> 00:45:31.800
Ну и в самом конце познакомились с сервисом
для быстрого развертывания в веб-приложении.

00:45:31.800 --> 00:45:41.080
Это AWS Elastic Beanstalk. Вы видите, что
AWS предоставляет широкий выбор сервисов

00:45:41.080 --> 00:45:48.240
и в зависимости от вашей бизнес потребности для
вас могут подойти один или несколько вариантов,

00:45:48.240 --> 00:45:53.920
которые вы будете использовать. Оно будет
максимально эффективно и выгодно для вас.

00:45:53.920 --> 00:46:00.480
Если вам необходима дополнительная информация
по тому или иному сервису, здесь вы видите

00:46:00.480 --> 00:46:07.640
дополнительные ссылки, которые вам могут быть
полезны. На этом мы завершаем наше сегодняшнее

00:46:07.740 --> 00:46:12.880
лекционное занятие. Я надеюсь, вы
научились чему-то новому и увидимся с вами

00:46:12.880 --> 00:46:14.640
на следующих наших активностях.